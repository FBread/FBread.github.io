<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>面包土豆西红柿的博客</title>
  
  <subtitle>去火星看日出</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-19T07:11:46.586Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FBread</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ环境配置</title>
    <link href="http://yoursite.com/2019/11/19/%20RabbitMQ%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/11/19/ RabbitMQ环境配置/</id>
    <published>2019-11-19T01:48:16.000Z</published>
    <updated>2019-11-19T07:11:46.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ环境配置"><a href="#RabbitMQ环境配置" class="headerlink" title="RabbitMQ环境配置"></a>RabbitMQ环境配置</h2><p>1、RabbitMQ安装前首先要安装一个依赖环境erlang</p><p>下载地址：<a href="http://www.erlang.org/download.html" target="_blank" rel="noopener">http://www.erlang.org/download.html</a></p><p>下载后默认进行安装即可</p><a id="more"></a><p>2、下载RabbitMQ<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html</a></p><p>下载后默认安装即可</p><p>【说明】RabbitMQ有安装板和绿色免安装两个版本，下载哪个都可以，使用方式相同</p><p>3、配置环境变量</p><p>3.1：新建系统环境变量erlang环境变量</p><p><img src="/assets/img/image-20191119101245436.png" alt="image-20191119101245436"></p><p>3.2：新建系统环境变量RabbitMQ环境变量</p><p><img src="/assets/img/image-20191119101316953.png" alt="image-20191119101316953"></p><p>3.3：编辑path环境变量，添加如下内容</p><p>   ;%ERLANG_HOME%\bin;%RABBITMQ_SERVER%\sbin;</p><p>4、启动监控管理器：</p><p>4.1：打开cmd窗口</p><p>4.2：在命令窗口中，进入RabbitMQ的安装路径下的sbin目录，执行命令如下：</p><p><img src="/assets/img/201911194.jpg" alt="img"></p><p>出现如下界面说明启动配置成功</p><p><img src="/assets/img/201911193.jpg" alt="img"></p><p>5、启动服务</p><p><img src="/assets/img/image-20191119101022398.png" alt="image-20191119101022398"></p><p>  <img src="/assets/img/201911192.jpg" alt="img"></p><p>6、在浏览器中输入如下网址：</p><p><a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a></p><p>登录名：guest</p><p>密码：guest</p><p>出现如下页面说明RabbitMQ配置成功</p><p><img src="/assets/img/20191119.jpg" alt="img"></p><h2 id="RabbitMQ常用命令"><a href="#RabbitMQ常用命令" class="headerlink" title="RabbitMQ常用命令"></a>RabbitMQ常用命令</h2><p>启动监控管理器：rabbitmq-plugins enable rabbitmq_management</p><p>关闭监控管理器：rabbitmq-plugins disable rabbitmq_management</p><p>启动rabbitmq：rabbitmq-service start</p><p>关闭rabbitmq：rabbitmq-service stop</p><p>查看所有的队列：rabbitmqctl list_queues</p><p>清除所有的队列：rabbitmqctl reset</p><p>关闭应用：rabbitmqctl stop_app</p><p>启动应用：rabbitmqctl start_app</p><p>用户和权限设置（后面用处）</p><p>添加用户：rabbitmqctl add_user username password</p><p>分配角色：rabbitmqctl set_user_tags username administrator</p><p>新增虚拟主机：rabbitmqctl add_vhost  vhost_name</p><p>将新虚拟主机授权给新用户：rabbitmqctl set_permissions -p vhost_name username ‘.<em>‘ ‘.</em>‘ ‘.*’</p><p>角色说明</p><p>none  最小权限角色</p><p>management 管理员角色</p><p>policymaker  决策者</p><p>monitoring  监控</p><p>administrator  超级管理员</p><h2 id="MQ-dubbo测试"><a href="#MQ-dubbo测试" class="headerlink" title="MQ+dubbo测试"></a>MQ+dubbo测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> UserService us;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        声明队列的名字</span></span><br><span class="line">    String qName = <span class="string">"queue1902"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/addmq"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addMQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建MQ的连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置连接服务器的IP地址</span></span><br><span class="line">        factory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        <span class="comment">//设置服务器端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置登录账号密码</span></span><br><span class="line">        factory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过工厂创建一个连接</span></span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line">            <span class="comment">//通过连接对象创建管道:通过管道向MQ写入数据</span></span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//可以读取Redis中的数据</span></span><br><span class="line">            String strData = <span class="string">"s1001,50"</span>;</span><br><span class="line">            <span class="comment">//把数据写入MQ中</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, qName, <span class="keyword">null</span>, strData.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"写入消息队列成功"</span>);</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            channel.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ss"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getmq"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = factory.newConnection();</span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line">            <span class="comment">//设置管道读取参数</span></span><br><span class="line">            channel.queueDeclare(qName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">            System.out.println(<span class="string">"正在从消息队列读取数据"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建消费者</span></span><br><span class="line">            Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                <span class="comment">//通过内部类实现DefaultConsumer接口中的方法</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span></span><br><span class="line">                    <span class="comment">//参数body,就是从队列里获取的数据</span></span><br><span class="line">                    String str = <span class="keyword">new</span> String(body, UTF_8);</span><br><span class="line">                    String[] data = str.split(<span class="string">","</span>);</span><br><span class="line">                    <span class="comment">//创建UserScore对象</span></span><br><span class="line">                    UserScore userScore = <span class="keyword">new</span> UserScore();</span><br><span class="line">                    userScore.setUserId(data[<span class="number">0</span>]);</span><br><span class="line">                    userScore.setScore(Integer.parseInt(data[<span class="number">1</span>]));</span><br><span class="line">                    <span class="comment">//调用另一个程序(服务提供者)</span></span><br><span class="line">                    <span class="keyword">int</span> result = us.updateUserScore(userScore);</span><br><span class="line">                    <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"消息队列更新数据库成功"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"消息队列更新数据库失败"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//调用provider程序,写入数据库等</span></span><br><span class="line">                    System.out.println(<span class="string">"从队列中获取的数据"</span> + str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//消息确认机制--回复给MQ:ack消费者已经处理完成消息,此消息可以从消息队列中删除</span></span><br><span class="line">            channel.basicConsume(qName, <span class="keyword">true</span>, consumer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ环境配置&quot;&gt;&lt;a href=&quot;#RabbitMQ环境配置&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ环境配置&quot;&gt;&lt;/a&gt;RabbitMQ环境配置&lt;/h2&gt;&lt;p&gt;1、RabbitMQ安装前首先要安装一个依赖环境erlang&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://www.erlang.org/download.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.erlang.org/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载后默认进行安装即可&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MQ消息队列</title>
    <link href="http://yoursite.com/2019/11/18/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/11/18/MQ消息队列/</id>
    <published>2019-11-18T07:52:11.000Z</published>
    <updated>2019-11-19T02:39:28.266Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。</p><p>实现高性能，高可用，可伸缩和最终一致性架构。</p><p>使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。</p><a id="more"></a><p><strong>02</strong></p><h2 id="消息队列应用场景"><a href="#消息队列应用场景" class="headerlink" title="消息队列应用场景"></a>消息队列应用场景</h2><p>以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景</p><h3 id="2-1-异步处理"><a href="#2-1-异步处理" class="headerlink" title="2.1 异步处理"></a>2.1 异步处理</h3><p>场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式</p><h4 id="（1）串行方式"><a href="#（1）串行方式" class="headerlink" title="（1）串行方式"></a>（1）串行方式</h4><p>将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端</p><p><img src="/assets%5Cimg%5Cv2-f0a918e7424b7712bdd16a10ce63c99b_hd.jpg" alt="img"></p><h4 id="（2）并行方式"><a href="#（2）并行方式" class="headerlink" title="（2）并行方式"></a>（2）并行方式</h4><p>将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间</p><p><img src="/assets%5Cimg%5Cv2-8288398d4266144b2f08af47ac695ddf_hd.jpg" alt="img"></p><p>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。</p><p>因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）</p><blockquote><p>小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？</p></blockquote><p>引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：</p><img src="/assets\img\v2-88e488bdc09bbe6fe5a1db6a344adc74_hd.jpg" alt="img"><p>按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度 很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍</p><h3 id="2-2-应用解耦"><a href="#2-2-应用解耦" class="headerlink" title="2.2 应用解耦"></a>2.2 应用解耦</h3><p>场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图</p><p><img src="/assets%5Cimg%5Cv2-5007644bf7ffbea1aec56381e2db9b64_hd.jpg" alt="img"></p><p>传统模式的缺点：</p><ul><li>假如库存系统无法访问，则订单减库存将失败，从而导致订单失败</li><li>订单系统与库存系统耦合</li></ul><blockquote><p>如何解决以上问题呢？引入应用消息队列后的方案，如下图：</p></blockquote><p><img src="/assets%5Cimg%5Cv2-547be8af04ef807875541fb909601566_hd.jpg" alt="img"></p><ul><li>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功</li><li>库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作</li><li>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦</li></ul><h3 id="2-3-流量削锋"><a href="#2-3-流量削锋" class="headerlink" title="2.3 流量削锋"></a>2.3 流量削锋</h3><p>流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛</p><p>应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。</p><ul><li>可以控制活动的人数</li><li>可以缓解短时间内高流量压垮应用</li></ul><p><img src="/assets%5Cimg%5Cv2-99241c841f0a4f4929496d0d3b636128_hd.jpg" alt="img"></p><ul><li>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面</li><li>秒杀业务根据消息队列中的请求信息，再做后续处理</li></ul><h3 id="2-4-日志处理"><a href="#2-4-日志处理" class="headerlink" title="2.4 日志处理"></a><strong>2.4 日志处理</strong></h3><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下</p><p><img src="/assets%5Cimg%5Cv2-8ca67133d4973971f74b6e2092962432_hd.jpg" alt="img"></p><ul><li>日志采集客户端，负责日志数据采集，定时写受写入Kafka队列</li><li>Kafka消息队列，负责日志数据的接收，存储和转发</li><li>日志处理应用：订阅并消费kafka队列中的日志数据</li></ul><p>以下是新浪kafka日志处理应用案例</p><p><img src="/assets%5Cimg%5Cv2-51af6b1b68fb1b86e02968b09adcdadc_hd.jpg" alt="img"></p><p>(1)Kafka：接收用户日志的消息队列</p><p>(2)Logstash：做日志解析，统一成JSON输出给Elasticsearch</p><p>(3)Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能</p><p>(4)Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因</p><p>2.5 消息通讯</p><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等</p><p>点对点通讯：</p><p><img src="/assets%5Cimg%5Cv2-b1d687284d0bb59f362164c2744aecc9_hd.jpg" alt="img"></p><p>客户端A和客户端B使用同一队列，进行消息通讯。</p><p>聊天室通讯：</p><p><img src="/assets%5Cimg%5Cv2-0a329b2a1a2f48b6f51206ca15af38f4_hd.jpg" alt="img"></p><p>客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。</p><p>以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。</p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="/assets/img/clip_image001-1574131145302.jpg" alt="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3325161782,1490031502&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=352&amp;s=0150CD3291DF49CA4ED4D9CA030070B1"></p><p>几个概念说明:</p><p>Broker:它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输,</p><p>Exchange：消息交换机,它指定消息按什么规则,路由到哪个队列。</p><p>Queue:消息的载体,每个消息都会被投到一个或多个队列。</p><p>Binding:绑定，它的作用就是把exchange和queue按照路由规则绑定起来.</p><p>Routing Key:路由关键字,exchange根据这个关键字进行消息投递。</p><p>vhost:虚拟主机,一个broker里可以有多个vhost，用作不同用户的权限分离。</p><p>Producer:消息生产者,就是投递消息的程序.</p><p>Consumer:消息消费者,就是接受消息的程序.</p><p>Channel:消息通道,在客户端的每个连接里,可建立多个channel.</p><h3 id="4-任务分发机制"><a href="#4-任务分发机制" class="headerlink" title="4.任务分发机制"></a>4.任务分发机制</h3><p>4.1Round-robin dispathching循环分发</p><p>RabbbitMQ的分发机制非常适合扩展,而且它是专门为并发程序设计的,如果现在load加重,那么只需要创建更多的Consumer来进行任务处理。</p><p>4.2Message acknowledgment消息确认</p><p>为了保证数据不被丢失,RabbitMQ支持消息确认机制,为了保证数据能被正确处理而不仅仅是被Consumer收到,那么我们不能采用no-ack，而应该是在处理完数据之后发送ack.</p><p>在处理完数据之后发送ack,就是告诉RabbitMQ数据已经被接收,处理完成,RabbitMQ可以安全的删除它了.</p><p>如果Consumer退出了但是没有发送ack,那么RabbitMQ就会把这个Message发送到下一个Consumer，这样就保证在Consumer异常退出情况下数据也不会丢失.</p><p>RabbitMQ它没有用到超时机制.RabbitMQ仅仅通过Consumer的连接中断来确认该Message并没有正确处理，也就是说RabbitMQ给了Consumer足够长的时间做数据处理。</p><p>如果忘记ack,那么当Consumer退出时,Mesage会重新分发,然后RabbitMQ会占用越来越多的内存.</p><h3 id="5-Message-durability消息持久化"><a href="#5-Message-durability消息持久化" class="headerlink" title="5.Message durability消息持久化"></a>5.Message durability消息持久化</h3><p>要持久化队列queue的持久化需要在声明时指定durable=True;</p><p>这里要注意,队列的名字一定要是Broker中不存在的,不然不能改变此队列的任何属性.</p><p>队列和交换机有一个创建时候指定的标志durable,durable的唯一含义就是具有这个标志的队列和交换机会在重启之后重新建立,它不表示说在队列中的消息会在重启后恢复</p><p>消息持久化包括3部分</p><p>\1. exchange持久化,在声明时指定durable =&gt; true</p><p>hannel.ExchangeDeclare(ExchangeName, “direct”, durable: true, autoDelete: false, arguments: null);//声明消息队列，且为可持久化的</p><p>2.queue持久化,在声明时指定durable =&gt; true</p><p>channel.QueueDeclare(QueueName, durable: true, exclusive: false, autoDelete: false, arguments: null);//声明消息队列，且为可持久化的</p><p>3.消息持久化,在投递时指定delivery_mode =&gt; 2(1是非持久化).</p><p>channel.basicPublish(“”, queueName, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</p><p>如果exchange和queue都是持久化的,那么它们之间的binding也是持久化的,如果exchange和queue两者之间有一个持久化，一个非持久化,则不允许建立绑定.</p><p>注意：一旦创建了队列和交换机,就不能修改其标志了,例如,创建了一个non-durable的队列,然后想把它改变成durable的,唯一的办法就是删除这个队列然后重现创建。</p><h3 id="6-Fair-dispath-公平分发"><a href="#6-Fair-dispath-公平分发" class="headerlink" title="6.Fair dispath 公平分发"></a>6.Fair dispath 公平分发</h3><p>你可能也注意到了,分发机制不是那么优雅,默认状态下,RabbitMQ将第n个Message分发给第n个Consumer。n是取余后的,它不管Consumer是否还有unacked Message，只是按照这个默认的机制进行分发.</p><p>那么如果有个Consumer工作比较重,那么就会导致有的Consumer基本没事可做,有的Consumer却毫无休息的机会,那么,Rabbit是如何处理这种问题呢</p><p>通过basic.qos方法设置prefetch_count=1，这样RabbitMQ就会使得每个Consumer在同一个时间点最多处理一个Message，换句话说,在接收到该Consumer的ack前,它不会将新的Message分发给它</p><p>channel.basic_qos(prefetch_count=1)</p><p>注意，这种方法可能会导致queue满。当然，这种情况下你可能需要添加更多的Consumer，或者创建更多的virtualHost来细化你的设计。</p><h3 id="7-分发到多个Consumer"><a href="#7-分发到多个Consumer" class="headerlink" title="7.分发到多个Consumer"></a>7.分发到多个Consumer</h3><p>7.1Exchange</p><p>先来温习以下交换机路由的几种类型:</p><p>Direct Exchange:直接匹配,通过Exchange名称+RountingKey来发送与接收消息.</p><p>Fanout Exchange:广播订阅,向所有的消费者发布消息,但是只有消费者将队列绑定到该路由器才能收到消息,忽略Routing Key.</p><p>Topic Exchange：主题匹配订阅,这里的主题指的是RoutingKey,RoutingKey可以采用通配符,如:*或#，RoutingKey命名采用.来分隔多个词,只有消息这将队列绑定到该路由器且指定RoutingKey符合匹配规则时才能收到消息;</p><p>Headers Exchange:消息头订阅,消息发布前,为消息定义一个或多个键值对的消息头,然后消费者接收消息同时需要定义类似的键值对请求头:(如:x-mactch=all或者x_match=any)，只有请求头与消息头匹配,才能接收消息,忽略RoutingKey.</p><p>默认的exchange:如果用空字符串去声明一个exchange，那么系统就会使用”amq.direct”这个exchange，我们创建一个queue时,默认的都会有一个和新建queue同名的routingKey绑定到这个默认的exchange上去</p><p>channel.BasicPublish(“”, “TaskQueue”, properties, bytes);</p><p>1</p><p>因为在第一个参数选择了默认的exchange，而我们申明的队列叫TaskQueue，所以默认的，它在新建一个也叫TaskQueue的routingKey，并绑定在默认的exchange上，导致了我们可以在第二个参数routingKey中写TaskQueue，这样它就会找到定义的同名的queue，并把消息放进去。</p><p>如果有两个接收程序都是用了同一个的queue和相同的routingKey去绑定direct exchange的话，分发的行为是负载均衡的，也就是说第一个是程序1收到，第二个是程序2收到，以此类推。</p><p>如果有两个接收程序用了各自的queue，但使用相同的routingKey去绑定direct exchange的话，分发的行为是复制的，也就是说每个程序都会收到这个消息的副本。行为相当于fanout类型的exchange。</p><p>下面详细来说:</p><p>7.2 Bindings 绑定</p><p>绑定其实就是关联了exchange和queue，或者这么说:queue对exchange的内容感兴趣,exchange要把它的Message deliver到queue。</p><p>7.3Direct exchange</p><p>Driect exchange的路由算法非常简单:通过bindingkey的完全匹配，可以用下图来说明.</p><p>Exchange和两个队列绑定在一起,Q1的bindingkey是orange，Q2的binding key是black和green.</p><p>当Producer publish key是orange时,exchange会把它放到Q1上,如果是black或green就会到Q2上,其余的Message被丢弃.</p><p>7.4 Multiple bindings</p><p>多个queue绑定同一个key也是可以的,对于下图的例子,Q1和Q2都绑定了black,对于routing key是black的Message，会被deliver到Q1和Q2，其余的Message都会被丢弃.</p><p>7.5 Topic exchange</p><p>对于Message的routing_key是有限制的，不能使任意的。格式是以点号“.”分割的字符表。比如：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”。你可以放任意的key在routing_key中，当然最长不能超过255 bytes。</p><p>对于routing_key，有两个特殊字符</p><p>*(星号)代表任意一个单词</p><p>#(hash)0个或多个单词</p><p>Producer发送消息时需要设置routing_key，routing_key包含三个单词和连个点号o,第一个key描述了celerity(灵巧),第二个是color(色彩),第三个是物种:</p><p>在这里我们创建了两个绑定： Q1 的binding key 是”.orange.“； Q2 是 “..rabbit” 和 “lazy.#”：</p><p>Q1感兴趣所有orange颜色的动物 Q2感兴趣所有rabbits和所有的lazy的.</p><p>例子:rounting_key 为 “quick.orange.rabbit”将会发送到Q1和Q2中</p><p>rounting_key 为”lazy.orange.rabbit.hujj.ddd”会被投递到Q2中,#匹配0个或多个单词。</p><p>8.消息序列化</p><p>RabbitMQ使用ProtoBuf序列化消息,它可作为RabbitMQ的Message的数据格式进行传输,由于是结构化的数据,这样就极大的方便了Consumer的数据高效处理,当然也可以使用XML，与XML相比,ProtoBuf有以下优势:</p><p>1.简单</p><p>2.size小了3-10倍</p><p>3.速度快了20-100倍</p><p>4.易于编程</p><p>6.减少了语义的歧义.</p><p>，ProtoBuf具有速度和空间的优势，使得它现在应用非常广泛</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。&lt;/p&gt;
&lt;p&gt;实现高性能，高可用，可伸缩和最终一致性架构。&lt;/p&gt;
&lt;p&gt;使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>idea连数据库</title>
    <link href="http://yoursite.com/2019/11/15/idea%E8%BF%9E%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2019/11/15/idea连数据库/</id>
    <published>2019-11-15T09:23:32.000Z</published>
    <updated>2019-11-18T05:30:32.376Z</updated>
    
    <content type="html"><![CDATA[<p>idea连数据库时超时错误</p><p>将url改为:</p><p><code>jdbc:mysql://localhost:3306/webuser?useSSL=false&amp;serverTimezone=Hongkong&amp;characterEncoding=utf-8&amp;autoReconnect=true</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;idea连数据库时超时错误&lt;/p&gt;
&lt;p&gt;将url改为:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jdbc:mysql://localhost:3306/webuser?useSSL=false&amp;amp;serverTimezone=Hongkong&amp;amp;characterEncod
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【ZOOKEEPER】报错-DZOOKEEPER.LOG.DIR=XXX... 不是内部或外部命令，也不是可运行的程序 或批处理文件的解决</title>
    <link href="http://yoursite.com/2019/11/15/%E3%80%90ZOOKEEPER%E3%80%91%E6%8A%A5%E9%94%99-DZOOKEEPER-LOG-DIR-XXX-%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F-%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2019/11/15/【ZOOKEEPER】报错-DZOOKEEPER-LOG-DIR-XXX-不是内部或外部命令，也不是可运行的程序-或批处理文件的解决/</id>
    <published>2019-11-15T08:18:03.000Z</published>
    <updated>2019-11-19T01:49:13.452Z</updated>
    
    <content type="html"><![CDATA[<p>感谢大佬:<a href="http://www.freesion.com/article/235010523/" target="_blank" rel="noopener">http://www.freesion.com/article/235010523/</a></p><p><img src="/assets/img/image-20191115162052881.png" alt="image-20191115162052881"></p><p> 修改zkServer.cmd文件 </p><p><img src="/assets%5Cimg%5Cimage-20191115162256082.png" alt="image-20191115162256082"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;感谢大佬:&lt;a href=&quot;http://www.freesion.com/article/235010523/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.freesion.com/article/235010523/&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="error" scheme="http://yoursite.com/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>dubbo&amp;zookeeper聚合项目</title>
    <link href="http://yoursite.com/2019/11/15/dubbo-zookeeper%E8%81%9A%E5%90%88%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/11/15/dubbo-zookeeper聚合项目/</id>
    <published>2019-11-15T02:22:33.000Z</published>
    <updated>2019-11-15T07:15:16.927Z</updated>
    
    <content type="html"><![CDATA[<p>父工程不运行任何程序,只做版本控制</p><p>新建maven项目<br>在pom中添加<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code><br>新建modules<br>interface:<br>    约束方法 jar</p><p>provider:war</p><p>​    业务逻辑处理,数据访问</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;父工程不运行任何程序,只做版本控制&lt;/p&gt;
&lt;p&gt;新建maven项目&lt;br&gt;在pom中添加&lt;code&gt;&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;&lt;/code&gt;&lt;br&gt;新建modules&lt;br&gt;interface:&lt;br&gt;    约束方法 j
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>1115面试题</title>
    <link href="http://yoursite.com/2019/11/15/1115%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/11/15/1115面试题/</id>
    <published>2019-11-15T01:44:21.000Z</published>
    <updated>2019-11-19T02:20:42.128Z</updated>
    
    <content type="html"><![CDATA[<p>多线程，io/nio，jvm，集合底层，tcp/ip协议，socket，websocket。spring，springmvc，xml，设计模式，eclipse plugin开发，数据库，前端（基本没有什么人问，面的后端开发，也许熟悉前端也是加分项）了解netty、mybatis、redis<br> springmvc，mybatis，redis，activemq，阿里云对象存储 </p><a id="more"></a><p> 多线程，线程池拒绝策略，jvm调优，tomcat调优，消息中间件，分布式，集群，zookeeper，微服务。sql左连接右连接区别，存储过程。linux </p><p>stringbuffer和stringbuild区别，stringbuild线程不安全体现在哪，你对线程安不安全怎么理解（这个问题发挥空间很大，关键词:全局变量、JVM运行时数据区、可见性、原子性、锁、甚至可以说到多核cpu硬件层面(我是不会的)），arraylist和linkedlist区别，spring ioc，aop作用，原理。springmvc执行流程（这种问题最扯淡），hashmap原理（问的很浅，底层结构，答数组+链表/红黑树。他就没问了），hashmap,hashtable,concurrentHashMap(大致基本说下，他就不问了),hashmap遍历。对大数据有关技术了解多少(答:了解一点，听过hadoop)。其它忘了，总体难度不大。写代码:字符串分割排序(split+冒泡)）<br>问的项目业务，公司业务模块（无从下口），为什么要用redis，相比于如memcached,mongodb有什么优势，mybatis，activemq。springmvc有什么好处，为什么要用它,springmvc和struts区别(都不会)…用过什么数据库，有没有做过数据库优化，什么情况下要用到索引，好处是什么，哪些字段适合建立索引，mysql索引底层数据结构了解吗，索引什么情况下会失效，联合索引abc只用了a字段，索引是否会生效。什么情况下要用到多线程，为什么要用，好处。启动多个线程，如何知道他们都运行完毕了。jquery要想取某个节点中的第几个元素怎么写，具体哪个方法（（我看你是闲着蛋疼）答：元素选择器,find,eq）。 总体回答的很不好，感觉他就盯着我写的了解程度的技术问，有为难我降低我薪资要求的意思。最后通知面试通过（也许是真的缺人，也许是我吹牛比较6，画了项目流程图给他）<br>string为什么是不可变的，重写重载，object类有哪些方法，sleep和wait区别，实现线程的方式，run，start区别，线程有几种状态，synchronize实现原理（这个问题可以说的很多，建议大家往深了看，往深了说，以震慑面试官），与lock区别，还知道哪些锁，说说自旋锁。线程池，线程池等待队列，拒绝策略，死锁产生原因。为什么java可以一次编译，到处运行。事务特性，索引失效，mysql有哪些函数。http和https区别，get和post区别，springbean是单例吗，spring源码看过吗，其中的单例bean是怎么实现的。redis有支持哪些数据结构。servlet怎么取前端参数。（两个面试官，感觉面试官水平有限，一直在想问什么问题，越问越没难度）设计个洗牌算法。线上购物车需要有个标志唯一id，有什么方法实现这个id（uuid，参考jdk中random实现原理，取随机种子）</p><p>抽象类接口区别，接口中可以定义成员变量吗，默认是什么类型的变量（public static final），接口中方法权限可以是private吗，接口是否可以写具体实现（答：jdk8开始可以）重写重载区别，线程的实现方式（我已经感觉到这个部门有多缺人了）。sql交并集，事务隔离级别。能调用另一个类的私有方法吗，怎么做。如果线程池执行shutdown或shutdownNow，线程池中线程会中断吗，会出现什么异常，catch处理中该写些什么。用过哪些concurrent包下的类，说说原子类，cas操作可能会存在什么问题。jdk中有哪些设计模式的运用，项目中用了哪些设计模式，treemap中compartor用了什么设计模式，有哪些单例模式的实现方式，springbean是单例吗。如果想要在某些自己指定的某些方法前后打印日志怎么实现（答：自定义注解，问：具体怎么做，答：spring aop的实现思路…），注解实现原理。</p><p>servlet和jsp区别，如果没有servlet，jsp怎么跟后端交互（大概是这个意思，没听太懂，一脸懵逼）。springmvc怎么取前端数据，springmvc模式下，如果没有注解怎么取前端参数（答：servlet，requset.getParameter。他问，具体在哪怎么用，也没听太懂，懵逼）。搭建springmvc项目步骤。spirngmvc controller中定义全局hashmap，它是否是线程安全的，为什么。</p><p>Io nio区别，nio原理。netty用的多吗。答，不多。</p><p>项目中用哪种方式解析xml的 答:jaxb,dom4j,digester。问:jaxp是什么。 答:是jaxb,巴拉巴拉… 问:哦哦，挺好用的</p><p>servlet生命周期。tomcat在初始化中做了什么事（答：启动socket服务端…问:没了吗?答:… 很明显该回答的还有很多，想了解的应该是我对tomcat的理解程度，以及是否看过tomcat源码）。是否用过Nginx。过滤器和拦截器的区别。</p><p>项目中有用到缓存吗，redis有提供了哪些存储数据结构，redis持久化。</p><p>说说java内存模型，新生代老年代算法，你说的新生代老年代属于堆还是栈，还知道哪些gc算法，创建大对象也是在新生代分配吗，（答：直接晋升进入老年代，问：具体多大对象，答：超过eden区大小，问：你是否确定，顿时虚了，后来回去查阅过，我回答的不对，jvm这里的看点很多，涉及到优化）。新生代的算法，说说minor gc,minor gc触发条件。老年代用了什么算法，说说标记整理算法，full gc是否真正回收了废弃对象。有哪些gc策略。你觉得你的项目中如果需要jvm调优你会注重哪个分带的调优，或者说更注重哪种gc调优，为什么，具体怎么做（懵逼，随便吹了下。问：你确定吗？  顿时又虚了）。</p><p>线上系统每天会收到20万级的数据，一个月会有百万条，并且还会递增。你如何设计数据库（答:分库分表，建立索引，问：分库分表对的，还有哪些点，分库分表按什么规则分）。如果查询字段不是分库分表的规则字段，怎么办（他说没事，想到什么说什么，也许你的思路会比我们的更好，你说说看）。沉默许久，不会，没接触过。（后来查了该问题：分库分表多维度查询）问:oracle分页的sql关键字是什么 答:limit 问:不对吧，那是mysql的 答:啊？好吧 问:也许是limit，我也记不清了，可能你说的是对的，回去我得看看。（面试官还算和蔼，其实是rownum）<br>。3个技术人员依次提问，jdbc连接步骤，statement和prepareStatement区别，项目中数据库事务控制你们是怎么做的。TreeMap,TreeSet,HashSet实现原理(之前只看了hashmap（别人都问hashmap,偏偏他就不问，这公司有套路的）其它回答的不好。这次面试经验很重要-所有集合实现都得认真看一遍),dom4j怎么取节点。为什么重写equals方法最好也得重写hashcode。treeMap中元素怎么排序，如果没实现comparator接口会怎么样。序列化作用。</p><p>2面，也是3个人，项目经理（从言谈中看得出来技术沉淀很不错）+HR+不知道什么人(女，基本没说话)。都是项目经理问。自我介绍，项目介绍，项目细节（问的很细致）。项目中有用到多线程，线程池吗，怎么用的。说说你对hash的理解。hashSet是怎么去重的。你知道哪些map,set，说说他们实现原理。红黑树，二叉树。sql优化。linux。socket长连接短连接，连接出现异常你是怎么处理的。定时器。如果cpu有8个核心，那么程序启动多少个线程相对合适（懵逼）。</p><p> treeMap元素排序。项目中是否做过jvm优化，sql优化。gc算法。是否用过webservice。mybatis分页,redis有关问题。BIO,NIO,AIO区别。高并发情况下怎么降低服务器压力（暂不从增加服务器和硬件提升层面考虑），方案解决问题:</p><p>   1.假如servlet处理一个请求需要0.4秒，那么处理100请求大概需要多久，为什么。同时处理1000个请求导致服务器压力过大崩溃怎么解决</p><p>  2.线上系统造成服务器cpu占用率过高问题（网上有解决方案） </p><p>  3.秒杀系统少卖超卖问题怎么处理（网上有解决方案）</p><p>4.有个业务场景，通过第三方工具收集到大概百万条手机号，存储到文本中，文本中每行一个号码。我们的数据库中会存每个号码对应的会员等级信息(也有可能这个号码在数据库中不存在,那么他就是新用户)。按会员等级给号码发送不同内容的信息，新号码发送邀请信息。设计一个方案，怎么做效率最高（数据库数据量很大）。</p><h4 id="JDBC流程"><a href="#JDBC流程" class="headerlink" title="JDBC流程:"></a>JDBC流程:</h4><p>1.加载jar<br>2.Class.forName(“”);<br>3.Connection conn = DriverManager.getConnection(url,name,pwd);<br>4.PreparedStatement ps = conn.createStatement(sql);<br>5.Int result = ps.executeUpdate();<br>6.ResultSet rs = ps.executeQuery();</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程，io/nio，jvm，集合底层，tcp/ip协议，socket，websocket。spring，springmvc，xml，设计模式，eclipse plugin开发，数据库，前端（基本没有什么人问，面的后端开发，也许熟悉前端也是加分项）了解netty、mybatis、redis&lt;br&gt; springmvc，mybatis，redis，activemq，阿里云对象存储 &lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Redis和mysql数据同步</title>
    <link href="http://yoursite.com/2019/11/15/Redis%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2019/11/15/Redis和mysql数据同步/</id>
    <published>2019-11-15T01:30:18.000Z</published>
    <updated>2019-11-19T00:45:33.633Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>并发量小的:业务逻辑层直接同步</p></li><li><p>并发量大的:写数据时,先直接写到Redis中.</p><p>方案1:设置定时任务,在某一个时间点同步到数据库中.</p><p>方案2:消息队列MQ,</p></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;并发量小的:业务逻辑层直接同步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并发量大的:写数据时,先直接写到Redis中.&lt;/p&gt;
&lt;p&gt;方案1:设置定时任务,在某一个时间点同步到数据库中.&lt;/p&gt;
&lt;p&gt;方案2:消息队列MQ,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java常见异常</title>
    <link href="http://yoursite.com/2019/11/15/Java%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/11/15/Java常见异常/</id>
    <published>2019-11-15T00:17:05.000Z</published>
    <updated>2019-11-15T00:17:49.413Z</updated>
    
    <content type="html"><![CDATA[<p>转自: <a href="https://www.cnblogs.com/cvst/p/5822373.html" target="_blank" rel="noopener">https://www.cnblogs.com/cvst/p/5822373.html</a> </p><p>Java Exception：</p><p>1、Error<br>2、Runtime Exception 运行时异常<br>3、Exception<br>4、throw 用户自定义异常</p><a id="more"></a><p>异常类分两大类型：Error类代表了编译和系统的错误，不允许捕获；Exception类代表了标准Java库方法所激发的异常。Exception类还包含运行异常类Runtime_Exception和非运行异常类Non_RuntimeException这两个直接的子类。</p><p>运行异常类对应于编译错误，它是指Java程序在运行时产生的由解释器引发的各种异常。运行异常可能出现在任何地方，且出现频率很高，因此为了避免巨大的系统资源开销，编译器不对异常进行检查。所以Java语言中的运行异常不一定被捕获。出现运行错误往往表示代码有错误，如：算数异常（如被0除）、下标异常（如数组越界）等。</p><p>非运行异常时Non_RuntimeException类及其子类的实例，又称为可检测异常。Java编译器利用分析方法或构造方法中可能产生的结果来检测Java程序中是否含有检测异常的处理程序，对于每个可能的可检测异常，方法或构造方法的throws子句必须列出该异常对应的类。在Java的标准包java.lang java.util 和 java.net 中定义的异常都是非运行异常。</p><p>算术异常类：ArithmeticExecption</p><p>空指针异常类：NullPointerException</p><p>类型强制转换异常：ClassCastException</p><p>数组负下标异常：NegativeArrayException</p><p>数组下标越界异常：ArrayIndexOutOfBoundsException</p><p>违背安全原则异常：SecturityException</p><p>文件已结束异常：EOFException</p><p>文件未找到异常：FileNotFoundException</p><p>字符串转换为数字异常：NumberFormatException</p><p>操作数据库异常：SQLException</p><p>输入输出异常：IOException</p><p>方法未找到异常：NoSuchMethodException</p><p>java.lang.AbstractMethodError</p><p>抽象方法错误。当应用试图调用抽象方法时抛出。</p><p>java.lang.AssertionError</p><p>断言错。用来指示一个断言失败的情况。</p><p>java.lang.ClassCircularityError</p><p>类循环依赖错误。在初始化一个类时，若检测到类之间循环依赖则抛出该异常。</p><p>java.lang.ClassFormatError</p><p>类格式错误。当Java虚拟机试图从一个文件中读取Java类，而检测到该文件的内容不符合类的有效格式时抛出。</p><p>java.lang.Error</p><p>错误。是所有错误的基类，用于标识严重的程序运行问题。这些问题通常描述一些不应被应用程序捕获的反常情况。</p><p>java.lang.ExceptionInInitializerError</p><p>初始化程序错误。当执行一个类的静态初始化程序的过程中，发生了异常时抛出。静态初始化程序是指直接包含于类中的static语句段。</p><p>java.lang.IllegalAccessError</p><p>违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p><p>java.lang.IncompatibleClassChangeError</p><p>不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。</p><p>java.lang.InstantiationError</p><p>实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p><p>java.lang.InternalError</p><p>内部错误。用于指示Java虚拟机发生了内部错误。</p><p>java.lang.LinkageError</p><p>链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。</p><p>java.lang.NoClassDefFoundError</p><p>未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。</p><p>java.lang.NoSuchFieldError</p><p>域不存在错误。当应用试图访问或者修改某类的某个域，而该类的定义中没有该域的定义时抛出该错误。</p><p>java.lang.NoSuchMethodError</p><p>方法不存在错误。当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误。</p><p>java.lang.OutOfMemoryError</p><p>内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p><p>java.lang.StackOverflowError</p><p>堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误。</p><p>java.lang.ThreadDeath</p><p>线程结束。当调用Thread类的stop方法时抛出该错误，用于指示线程结束。</p><p>java.lang.UnknownError</p><p>未知错误。用于指示Java虚拟机发生了未知严重错误的情况。</p><p>java.lang.UnsatisfiedLinkError</p><p>未满足的链接错误。当Java虚拟机未找到某个类的声明为native方法的本机语言定义时抛出。</p><p>java.lang.UnsupportedClassVersionError</p><p>不支持的类版本错误。当Java虚拟机试图从读取某个类文件，但是发现该文件的主、次版本号不被当前Java虚拟机支持的时候，抛出该错误。</p><p>java.lang.VerifyError</p><p>验证错误。当验证器检测到某个类文件中存在内部不兼容或者安全问题时抛出该错误。</p><p>java.lang.VirtualMachineError</p><p>虚拟机错误。用于指示虚拟机被破坏或者继续执行操作所需的资源不足的情况。</p><p>java.lang.ArithmeticException</p><p>算术条件异常。譬如：整数除零等。</p><p>java.lang.ArrayIndexOutOfBoundsException</p><p>数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p><p>java.lang.ArrayStoreException</p><p>数组存储异常。当向数组中存放非数组声明类型对象时抛出。</p><p>java.lang.ClassCastException</p><p>类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p><p>java.lang.ClassNotFoundException</p><p>找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p><p>java.lang.CloneNotSupportedException</p><p>不支持克隆异常。当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。</p><p>java.lang.EnumConstantNotPresentException</p><p>枚举常量不存在异常。当应用试图通过名称和枚举类型访问一个枚举对象，但该枚举对象并不包含常量时，抛出该异常。</p><p>java.lang.Exception</p><p>根异常。用以描述应用程序希望捕获的情况。</p><p>java.lang.IllegalAccessException</p><p>违法的访问异常。当应用试图通过反射方式创建某个类的实例、访问该类属性、调用该类方法，而当时又无法访问类的、属性的、方法的或构造方法的定义时抛出该异常。</p><p>java.lang.IllegalMonitorStateException</p><p>违法的监控状态异常。当某个线程试图等待一个自己并不拥有的对象（O）的监控器或者通知其他线程等待该对象（O）的监控器时，抛出该异常。</p><p>java.lang.IllegalStateException</p><p>违法的状态异常。当在Java环境和应用尚未处于某个方法的合法调用状态，而调用了该方法时，抛出该异常。</p><p>java.lang.IllegalThreadStateException</p><p>违法的线程状态异常。当县城尚未处于某个方法的合法调用状态，而调用了该方法时，抛出异常。</p><p>java.lang.IndexOutOfBoundsException</p><p>索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</p><p>java.lang.InstantiationException</p><p>实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p><p>java.lang.InterruptedException</p><p>被中止异常。当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。</p><p>java.lang.NegativeArraySizeException</p><p>数组大小为负值异常。当使用负数大小值创建数组时抛出该异常。</p><p>java.lang.NoSuchFieldException</p><p>属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p><p>java.lang.NoSuchMethodException</p><p>方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p><p>java.lang.NullPointerException</p><p>空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p><p>java.lang.NumberFormatException</p><p>数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p><p>java.lang.RuntimeException</p><p>运行时异常。是所有Java虚拟机正常操作期间可以被抛出的异常的父类。</p><p>java.lang.SecurityException</p><p>安全异常。由安全管理器抛出，用于指示违反安全情况的异常。</p><p>java.lang.StringIndexOutOfBoundsException</p><p>字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</p><p>java.lang.TypeNotPresentException</p><p>类型不存在异常。当应用试图以某个类型名称的字符串表达方式访问该类型，但是根据给定的名称又找不到该类型是抛出该异常。该异常与ClassNotFoundException的区别在于该异常是unchecked（不被检查）异常，而ClassNotFoundException是checked（被检查）异常。</p><p>java.lang.UnsupportedOperationException</p><p>不支持的方法异常。指明请求的方法不被支持情况的异常。</p><p>异常<br>javax.servlet.jsp.JspException: Cannot retrieve mapping for action /Login （/Login是你的action名字）</p><p>可能原因<br>action没有再struts-config.xml 中定义，或没有找到匹配的action，例如在JSP文件中使用 &lt;html:form action=”Login.do”.将表单提交给Login.do处理，如果出现上述异常，请查看struts-config.xml中的定义部分，有时可能是打错了字符或者是某些不符合规则，可以使用strutsconsole工具来检查。<br>-—————————————————————————————————————-<br>异常<br>org.apache.jasper.JasperException: Cannot retrieve definition for form bean null</p><p>可能原因</p><p>这个异常是因为Struts根据struts-config.xml中的mapping没有找到action期望的form bean。大部分的情况可能是因为在form-bean中设置的name属性和action中设置的name属性不匹配所致。换句话说，action和form都应该各自有一个name属性，并且要精确匹配，包括大小写。这个错误当没有name属性和action关联时也会发生，如果没有在action中指定name属性，那么就没有name属性和action相关联。当然当action制作某些控制时，譬如根据参数值跳转到相应的jsp页面，而不是处理表单数据，这是就不用name属性，这也是action的使用方法之一。<br>-—————————————————————————————————————-<br>异常<br>No action instance for path /xxxx could be created</p><p>可能原因<br>特别提示：因为有很多中情况会导致这个错误的发生，所以推荐大家调高你的web服务器的日志/调试级别，这样可以从更多的信息中看到潜在的、在试图创建action类时发生的错误，这个action类你已经在struts-config.xml中设置了关联（即添加了<action>标签）。</action></p><p>在struts-config.xml中通过action标签的class属性指定的action类不能被找到有很多种原因，例如：定位编译后的.class文件失败。Failure to place compiled .class file for the action in the classpath (在web开发中，class的的位置在r WEB-INF/classes，所以你的action class必须要在这个目录下。例如你的action类位于WEB-INF/classes/action/Login.class,那么在struts-config.xml中设置action的属性type时就是action.Login).<br>拼写错误，这个也时有发生，并且不易找到，特别注意第一个字母的大小写和包的名称。<br>-—————————————————————————————————————-<br>异常<br>javax.servlet.jsp.JspException: No getter method for property username of bean org.apache.struts.taglib.html.BEAN</p><p>可能原因<br>没有位form bean中的某个变量定义getter 方法</p><p>这个错误主要发生在表单提交的FormBean中，用struts标记&lt;html:text property=”username”&gt;时，在FormBean中必须有一个getUsername()方法。注意字母“U”。<br>-—————————————————————————————————————-<br>异常<br>java.lang.NoClassDefFoundError: org/apache/struts/action/ActionForm</p><p>可能原因<br>这个错误主要发生在在classpath中找不到相应的Java .class文件。如果这个错误发生在web应用程序的运行时，主要是因为指定的class文件不在web server的classpath中（/WEB-INF/classes 和 /WEB-INF/lib）。在上面的错误中，原因是找不到ActionForm类。<br>-—————————————————————————————————————-<br>异常<br>javax.servlet.jsp.JspException: Exception creating bean of class org.apache.struts.action.ActionForm: {1}</p><p>可能原因<br>Instantiating Struts-provided ActionForm class directly instead of instantiating a class derived off ActionForm. This mightoccur implicitly if you specify that a form-bean is this Struts ActionForm class rather than specifying a child of this classfor the form-bean.</p><p>Not associating an ActionForm-descended class with an action can also lead to this error.<br>-—————————————————————————————————————-<br>异常<br>javax.servlet.jsp.JspException: Cannot find ActionMappings or ActionFormBeans collection</p><p>可能原因<br>不是标识Struts actionServlet的<servlet>标记就是映射.do扩展名的<sevlet-mapping>标记或者两者都没有在web.xml中声明。</sevlet-mapping></servlet></p><p>在struts-config.xml中的打字或者拼写错误也可导致这个异常的发生。例如缺少一个标记的关闭符号/&gt;。最好使用struts console工具检查一下。</p><p>另外，load-on-startup必须在web.xml中声明，这要么是一个空标记，要么指定一个数值，这个数值用来表servlet运行的优先级，数值越大优先级越低。</p><p>还有一个和使用load-on-startup有关的是使用Struts预编译JSP文件时也可能导致这个异常。<br>-—————————————————————————————————————-<br>异常<br>java.lang.NullPointerException at org.apache.struts.util.RequestUtils.forwardURL(RequestUtils.java:1223)</p><p>可能原因<br>在struts-config.xml中的forward元素缺少path属性。例如应该是如下形式：<br><forward name="userhome" path="/user/userhome.jsp"><br>-—————————————————————————————————————-<br>异常<br>javax.servlet.jsp.JspException: Cannot find bean org.apache.struts.taglib.html.BEAN in any scope</forward></p><p>Probable Causes<br>试图在Struts的form标记外使用form的子元素。这常常发生在你在后面使用Struts的html标记。另外要注意可能你不经意使用的无主体的标记，如&lt;html:form … /&gt;，这样web 服务器解析时就当作一个无主体的标记，随后使用的所有<html>标记都被认为是在这个标记之外的，如又使用了&lt;html:text property=”id”&gt;还有就是在使用taglib引入HTML标记库时，你使用的prefix的值不是html。<br>-—————————————————————————————————————-<br>异常<br>javax.servlet.jsp.JspException: Missing message for key xx.xx.xx</html></p><p>Probable Causes<br>这个key的值对没有在资源文件ApplicationResources.properties中定义。如果你使用eclipse时经常碰到这样的情况，当项目重新编译时，eclipse会自动将classes目录下的资源文件删除。</p><p>资源文件ApplicationResources.properties 不在classpath中应将资源文件放到 WEB-INF/classes 目录下，当然要在struts-config.xml中定义)<br>-—————————————————————————————————————-<br>异常<br>Cannot find message resources under key org.apache.struts.action.MESSAGE</p><p>可能原因<br>很显然，这个错误是发生在使用资源文件时，而Struts没有找到资源文件。</p><p>Implicitly trying to use message resources that are not available (such as using empty html:options tag instead of specifyingthe options in its body – this assumes options are specified in ApplicationResources.properties file)</p><p>XML parser issues – too many, too few, incorrect/incompatible versions<br>-—————————————————————————————————————-<br>异常<br>Strange and seemingly random characters in HTML and on screen, but not in original JSP or servlet.</p><p>可能原因<br>混和使用Struts的html:form标记和标准的HTML标记不正确。</p><p>使用的编码样式在本页中不支持。<br>-—————————————————————————————————————-<br>异常<br>“Document contained no data” in Netscape</p><p>No data rendered (completely empty) page in Microsoft Internet Explorer</p><p>可能原因<br>使用一个Action的派生类而没有实现perform()方法或execute()方法。在Struts1.0中实现的是perform()方法，在Struts1.1中实现的是execute()方法，但Struts1.1向后兼容perform()方法。但你使用Struts1.1创建一个Action的派生类，并且实现了execute()方法，而你在Struts1.0中运行的话，就会得到”Document contained nodata” error message in Netscape or a completely empty (no HTML whatsoever) page rendered in Microsoft Internet Explorer.”的错误信息。</p><p>-————————————————————————————————————————–<br>异常<br>ServletException: BeanUtils.populate<br>解决方案<br>在用Struts上传文件时,遇到了javax.servlet.ServletException: BeanUtils.populate异常。<br>我的ActionServlet并没有用到BeanUtils这些工具类。后来仔细检查代码发现是在jsp文件里的form忘了加enctype=”multipart/form-data” 了。所以写程序遇到错误或异常应该从多方面考虑问题存在的可能性，想到系统提示信息以外的东西。<br>-—————————————————————————————————————————<br>\1. 定义Action后, 如果指定了name, 那么必须要定义一个与它同名的FormBean才能进行form映射.2. 如果定义Action后, 提交页面时出现 “No input attribute for mapping path…” 错误, 则需要在其input属性中定义转向的页面.3. 如果插入新的数据时出现 “Batch update row count wrong:…” 错误, 则说明XXX.hbm.xml中指定的key的类型为原始类型(int, long),因为这种类型会自动分配值, 而这个值往往会让系统认为已经存在该记录, 正确的方法是使用java.lang.Integer或java.lang.Long对象.4. 如果插入数据时出现 “argument type mismatch” 错误, 可能是你使用了Date等特殊对象, 因为struts不能自动从String型转换成Date型,所以, 你需要在Action中手动把String型转换成Date型.5. Hibernate中, Query的iterator()比list()方法快很多.6. 如果出现 “equal symbol expected” 错误, 说明你的strtus标签中包含另一个标签或者变量, 例如:<br>&lt;html:select property=”test” onchange=”&lt;%=test%&gt;”/&gt;<br>或者<br>&lt;html:hidden property=”test” value=”&lt;bean:write name=”t” property=”p”/&gt;”/&gt;<br>这样的情况…<br>-————————————————————————————————————————–<br>错误：Exception in thread “main” org.hibernate.exception.SQLGrammarException: Could not execute JDBC batch update原因与解决： 因为Hibernate Tools（或者Eclipse本身的Database Explorer）生成<em>.hbn.xml工具中包含有catalog=”**</em>“（<em>表示数据库名称）这样的属性,将该属性删除就可以了<br>-————————————————————————————————————————–<br>错误：org.hibernate.ObjectDeletedException: deleted object would be re-saved by cascade (remove deleted object from associations)<br>原因与解决：<br>方法1 删除Set方的cascade<br>方法2 解决关联关系后，再删除<br>方法3 在many-to-one方增加cascade 但值不能是none<br>最后一招：<br>检查一下hashCode equals是否使用了id作为唯一标示的选项了；我用uuid.hex时是没有问题的；但是用了native，就不行了，怎么办？删除啊！<br>-—————————————————————————————————————————<br>问题：今天用Tomcat 5.5.12，发现原来很好用的系统不能用了，反复测试发现页面中不能包含 taglib，否则会出现以下提示：HTTP Status 500 -type Exception reportMessage description The server encountered an internal error () that prevented it from fulfilling this request.exceptionorg.apache.jasper.JasperException: /index.jsp(1,1) Unable to read TLD “META-INF/tlds/struts-bean.tld” from JAR file”file:****</em>/WEB-INF/lib/struts.jar”:原因：更新了工程用的lib文件夹下的jar，发布时也发布了servlet.jar和jsp-api.jar。解决：把jsp-api.jar删除就解决这个问题了。—————————————————————————————————————————–<br>错误： java.lang.NullPointerException<br>原因： 发现 dao 实例、 manage 实例等需要注入的东西没有被注入（俗称空指针异常）解决：这个时候，你应该查看日志文件；默认是应用服务器的 log 文件，比如 Tomcat 就是 [Tomcat 安装目录 ]/logs ；你会发现提示你：可能是：org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sf’ defined in ServletContextresource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception isorg.hibernate.HibernateException: could not configure from URL: file:src/hibernate.cfg.xmlorg.hibernate.HibernateException: could not configure from URL: file:src/hibernate.cfg.xml……………………….Caused by: java.io.FileNotFoundException: src\hibernate.cfg.xml可能是：org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined inServletContext resource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception isorg.hibernate.MappingException: Resource: com/mcc/coupon/model/UserRole.hbm.xml not foundorg.hibernate.MappingException: Resource: com/mcc/coupon/model/UserRole.hbm.xml not found然后你就知道原因是因为配置文件的解析出了错误，这个通过 Web 页面是看不出来的。更多的是持久化影射文件出的错误；导致了没有被解析；当然你需要的功能就无法使用了。<br>-—————————————————————————————————————————<br>错误：StandardWrapperValve[action]: Servlet.service() for servlet action threw exception<br>javax.servlet.jsp.JspException: Cannot retrieve mapping for action /settlementTypeManage<br>或者： type Status report message Servlet action is not available description The requested resource (Servlet action is not available) is not available.<br>原因： 同 上<br>-—————————————————————————————————————————<br>错误StandardWrapperValve[jsp]: Servlet.service() for servlet jsp threw exceptionjava.lang.ClassNotFoundException: org.apache.struts.taglib.bean.CookieTei界面错误具体描述：<br>org.apache.jasper.JasperException: Failed to load or instantiate TagExtraInfo class: org.apache.struts.taglib.bean.CookieTei<br>原因与解决： &lt;方案一&gt;你的“html:”开头的标签没有放在一个<a href="html:form" target="_blank" rel="noopener">html:form</a>中 &lt;方案二&gt;重新启动你的应用服务器，自动就没有这个问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自: &lt;a href=&quot;https://www.cnblogs.com/cvst/p/5822373.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/cvst/p/5822373.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;Java Exception：&lt;/p&gt;
&lt;p&gt;1、Error&lt;br&gt;2、Runtime Exception 运行时异常&lt;br&gt;3、Exception&lt;br&gt;4、throw 用户自定义异常&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="-Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>dubbo+zookeeper</title>
    <link href="http://yoursite.com/2019/11/13/dubbo-zookeeper/"/>
    <id>http://yoursite.com/2019/11/13/dubbo-zookeeper/</id>
    <published>2019-11-13T06:50:25.000Z</published>
    <updated>2019-11-19T01:31:38.690Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>单机结构:一个系统业务量很小的时候将所有代码都放在一个项目中,部署在一台服务器上,整个项目所有的服务都由这台服务器提供.</p><p>缺点:处理能力有限.业务增长时,无法满足需求.</p><a id="more"></a></li><li><p>集群结构:将单机复制几份,构成”集群”.集群中每台服务器称为一个”节点”,每个节点提供相同的服务.为了使每个节点的压力比较均衡,就要在所有节点之前加一个”调度者”的就角色,用户请求交给它,再由它根据当前所有节点的负载情况,决定将这个请求交给哪个节点处理.这就是”负载均衡服务器”.</p><p>集群扩展很容易,但是当业务发展到一定程度时,增加节点对集群性能的效果就不明显了.</p></li><li><p>分布式结构:分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。</p><p>举个例子，假设需要开发一个在线商城。按照微服务的思想，我们需要按照功能模块拆分成多个独立的服务，如：用户服务、产品服务、订单服务、后台管理服务、数据分析服务等等。这一个个服务都是一个个独立的项目，可以独立运行。如果服务之间有依赖关系，那么通过RPC方式调用。</p><p>这样的好处有很多：</p><ol><li>系统之间的耦合度大大降低，可以独立开发、独立部署、独立测试，系统与系统之间的边界非常明确，排错也变得相当容易，开发效率大大提升。</li><li>系统之间的耦合度降低，从而系统更易于扩展。我们可以针对性地扩展某些服务。假设这个商城要搞一次大促，下单量可能会大大提升，因此我们可以针对性地提升订单系统、产品系统的节点数量，而对于后台管理系统、数据分析系统而言，节点数量维持原有水平即可。</li><li>服务的复用性更高。比如，当我们将用户系统作为单独的服务后，该公司所有的产品都可以使用该系统作为用户系统，无需重复开发.</li></ol></li></ul><p><img src="/assets/img/001.PNG" alt></p><h2 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么"></a>Dubbo是什么</h2><p>​    Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC（一种远程调用） 分布式服务框架（SOA），致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。 </p><p>​    <img src="/assets%5Cimg%5Cimage-20191114140328431.png" alt="看下面"></p><p>​    </p><p><img src="/assets%5Cimg%5Cimage-20191114142237989.png" alt="image-20191114142237989"></p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>1.分布式系统<br>​    分布式应用的困难:局部故障</p><p>Zookeeper作用:注册、发现中心<br>​    </p><h4 id="zookeeper数据结构-Znode"><a href="#zookeeper数据结构-Znode" class="headerlink" title="zookeeper数据结构-Znode"></a>zookeeper数据结构-Znode</h4><p><img src="/assets/img/image-20191118152940321.png" alt="image-20191118152940321"></p><h3 id="Zookeeper环境搭建"><a href="#Zookeeper环境搭建" class="headerlink" title="Zookeeper环境搭建"></a>Zookeeper环境搭建</h3><p><img src="/assets/img/image-20191114152745644.png" alt="image-20191114152745644"></p><p>zookeeper<br>服务注册列表:注册的可用的服务<br>节点:每一个zookeeper服务是一个节点</p><h4 id="单节点模式"><a href="#单节点模式" class="headerlink" title="单节点模式"></a>单节点模式</h4><p><img src="/assets%5Cimg%5Cimage-20191118140212727.png" alt="image-20191118140212727"></p><p><img src="/assets%5Cimg%5Cimage-20191118140250643.png" alt="image-20191118140250643"></p><h4 id="单IP多节点-伪集群"><a href="#单IP多节点-伪集群" class="headerlink" title="单IP多节点(伪集群)"></a>单IP多节点(伪集群)</h4><p>修改配置文件,拷贝多份zookeeper文件.</p><p>server1:</p><p><img src="/assets%5Cimg%5Cimage-20191118140747504.png" alt="image-20191118140747504"></p><p><img src="/assets/img/image-20191118141001054.png" alt="image-20191118141001054"></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;单机结构:一个系统业务量很小的时候将所有代码都放在一个项目中,部署在一台服务器上,整个项目所有的服务都由这台服务器提供.&lt;/p&gt;
&lt;p&gt;缺点:处理能力有限.业务增长时,无法满足需求.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Redis-缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</title>
    <link href="http://yoursite.com/2019/11/13/Redis-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E3%80%81%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E3%80%81%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7/"/>
    <id>http://yoursite.com/2019/11/13/Redis-缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级/</id>
    <published>2019-11-13T03:29:02.000Z</published>
    <updated>2019-11-19T01:32:07.022Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://www.cnblogs.com/leesmall/p/8594542.html" target="_blank" rel="noopener">https://www.cnblogs.com/leesmall/p/8594542.html</a> </p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>​     大量的key设置了相同的过期时间，导致在缓存在同一时刻出现大面积的缓存过期，所有原本应该访问缓存的请求都去查询数据库了,造成瞬时DB请求量大、压力骤增 <a id="more"></a></p><p>，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p><p>缓存正常从Redis中获取，示意图如下：</p><p><img src="/assets%5Cimg%5C1521269040783ad8b0b3415.jfif" alt="阿里P8技术专家细究分布式缓存问题"></p><p>缓存失效瞬间示意图如下：</p><p><img src="/assets%5Cimg%5C15212690408812aad2545bb.jfif" alt="阿里P8技术专家细究分布式缓存问题"></p><p>解决方案:<br>1.保证Redis缓存层服务高可用性</p><p>2.依赖隔离组件为后端限流并降级</p><p>3.数据预热</p><p>1 事前：</p><ul><li><strong>使用集群缓存，保证缓存服务的高可用</strong></li></ul><p>这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。</p><p>2 事中：</p><ul><li><strong>ehcache本地缓存 + Hystrix限流&amp;降级,避免MySQL被打死</strong></li></ul><p>使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。</p><p>使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。</p><p>然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。</p><p>3 事后：</p><ul><li><strong>开启Redis持久化机制，尽快恢复缓存集群</strong></li></ul><p>一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</p><p>防止雪崩方案如下图所示：</p><p> <img src="/assets%5Cimg%5C169bb265aa52e948" alt="img"> </p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>​    访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉<br>这种查询不存在数据的现象我们称为缓存穿透。<br>拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致数据库由于压力过大而宕掉。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="1-缓存空值"><a href="#1-缓存空值" class="headerlink" title="1.缓存空值"></a>1.缓存空值</h4><p>之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。在访问key未在DB查询到值时，也将空值写进缓存，但可以设置较短过期时间.</p><h4 id="2-BloomFilterBloomFilter"><a href="#2-BloomFilterBloomFilter" class="headerlink" title="2.BloomFilterBloomFilter"></a>2.BloomFilterBloomFilter</h4><p> 采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤 .</p><p>类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中。这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB。流程图如下：</p><p><img src="/assets%5Cimg%5C169bb2638b91b339" alt="img"></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><img src="/assets%5Cimg%5Cimage-20191113141050681.png" alt="image-20191113141050681"></p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>系统上线后,将相关的缓存数据直接加载到缓存系统,避免用户请求的时候再去加载相关的数据.</p><h2 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h2><p>即缓存的淘汰机制</p><h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>​    当访问量剧增、服务出现问题(如响应时间慢或不反应)或非核心服务影响到核心流程的性能时,仍然需要保证服务还是可用的.降级的最终目的是保证核心服务可用,即使是有损的,而且有且服务是无法降级的(如加入购物车,结算等)</p><p>在进行降级之前要对系统尽心梳理,看看系统是不是可以丢卒保帅,从而树立出哪些必须誓死保护,哪些可以降级.</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>1 什么是击穿</p><p>在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为<strong>缓存击穿</strong>。</p><p>2 会带来什么问题</p><p>会造成某一时刻数据库请求量过大，压力剧增。</p><p>3 如何解决</p><p>上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。</p><p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;a href=&quot;https://www.cnblogs.com/leesmall/p/8594542.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/leesmall/p/8594542.html&lt;/a&gt; &lt;/p&gt;
&lt;h2 id=&quot;缓存雪崩&quot;&gt;&lt;a href=&quot;#缓存雪崩&quot; class=&quot;headerlink&quot; title=&quot;缓存雪崩&quot;&gt;&lt;/a&gt;缓存雪崩&lt;/h2&gt;&lt;p&gt;​     大量的key设置了相同的过期时间，导致在缓存在同一时刻出现大面积的缓存过期，所有原本应该访问缓存的请求都去查询数据库了,造成瞬时DB请求量大、压力骤增
    
    </summary>
    
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://yoursite.com/2019/11/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/11/13/Redis持久化/</id>
    <published>2019-11-13T01:41:53.000Z</published>
    <updated>2019-11-19T01:32:57.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis内存数据的淘汰机制"><a href="#Redis内存数据的淘汰机制" class="headerlink" title="Redis内存数据的淘汰机制"></a>Redis内存数据的淘汰机制</h2><p>​    Redis内存淘汰指的是用户存储的一些键被可以被Redis主动地从实例中删除，从而产生读miss的情况.<br>​    内存的淘汰机制的初衷是为了更好地使用内存，用一定的缓存miss来换取内存的使用效率.<br>存入数据时,指定有效时间</p><a id="more"></a><p><code># maxmemory &lt;bytes&gt;（100MB）</code>（最好为物理内存的75%左右）</p><ul><li><p>如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间，如果maxmemory过于接近主机的可用内存，导致数据同步时内存不足。所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。<br>maxmemory为0的时候表示我们对Redis的内存使用没有限制。</p><pre><code>我们可以通过配置redis.conf中的maxmemory这个值来开启内存淘汰功能，至于这个值有什么意义，我们可以通过了解内存淘汰的过程来理解它的意义：</code></pre></li></ul><ol><li><p>客户端发起了需要申请更多内存的命令（如set）。</p></li><li><p>Redis检查内存使用情况，如果已使用的内存大于maxmemory，则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存。</p></li><li><p>如果上面都没问题，则这个命令执行成功。</p></li></ol><p>Redis提供了下面几种淘汰策略供用户选择，其中默认的策略为noeviction策略：</p><p>1.volatile-lru:需要设置有效时间,优先把最近、最少使用的数据,从缓存中清理掉</p><p>2.noeviction：禁止驱逐数据。当内存使用达到阈值的时候，所有引起申请内存的命令会报错。（注意是写请求返回错误，读请求可以正常执行）</p><p>3.allkeys-lru：在主键空间中，优先移除最近未使用的key。</p><p>4.allkeys-random：在主键空间中，随机移除某个key。</p><p>5.volatile-random：在设置了过期时间的键空间中，随机移除某个key。</p><p>6.volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除</p><p>​      这里补充一下主键空间和设置了过期时间的键空间，举个例子，假设我们有一批键存储在Redis中，则有那么一个哈希表用于存储这批键及其值，如果这批键中有一部分设置了过期时间，那么这批键还会被存储到另外一个哈希表中，这个哈希表中的值对应的是键被设置的过期时间。设置了过期时间的键空间为主键空间的子集。</p><p>注意：redis 驱逐了某个键值对后，会删除这个数据，并将这个数据的变更消息发布到本地（AOF持久化）和从机（主从复制）。</p><p>我们了解了Redis大概提供了这么几种淘汰策略，那么如何选择呢？淘汰策略的选择可以通过下面的配置指定：</p><p><code># maxmemory-policy noeviction</code></p><p> ​      但是这个值填什么呢？为解决这个问题，我们需要了解我们的应用请求对于Redis中存储的数据集的访问方式以及我们的诉求是什么。同时Redis也支持Runtime修改淘汰策略，这使得我们不需要重启Redis实例而实时的调整内存淘汰策略。</p><p>下面看看几种策略的适用场景：</p><p>allkeys-lru：如果我们的应用对缓存的访问符合幂律分布（也就是存在相对热点数据），或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择allkeys-lru策略。<br>allkeys-random：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略。<br>volatile-ttl：这种策略使得我们可以向Redis提示哪些key更适合被eviction。<br>​       一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。       </p><p>​       另外，volatile-lru策略和volatile-random策略适合我们将一个Redis实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个Redis实例来达到相同的效果，值得一提的是将key设置过期时间实际上会消耗更多的内存，因此我们建议使用allkeys-lru策略从而更有效率的使用内存。</p><h2 id="Redis的持久化机制：RDB和AOF"><a href="#Redis的持久化机制：RDB和AOF" class="headerlink" title="Redis的持久化机制：RDB和AOF"></a>Redis的持久化机制：RDB和AOF</h2><p>转载的,具体见最后.</p><h3 id="什么是Redis持久化"><a href="#什么是Redis持久化" class="headerlink" title="什么是Redis持久化?"></a>什么是Redis持久化?</h3><p><code>Redis</code>作为一个键值对内存数据库(<code>NoSQL</code>)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，如下所示：</p><p><img src="/assets%5Cimg%5C16b91484c4f516d5" alt="img"></p><p>这样做有什么问题呢？</p><p>其实，只要稍微有点计算机基础知识的人都知道，存储在内存当中的数据，只要服务器关机(各种原因引起的)，内存中的数据就会消失了，不仅服务器关机会造成数据消失，<code>Redis</code>服务器守护进程退出，内存中的数据也一样会消失。</p><p><img src="/assets%5Cimg%5C16b914f6440bc352" alt="img"></p><p>对于只把<code>Redis</code>当缓存来用的项目来说，数据消失或许问题不大，重新从数据源把数据加载进来就可以了，但如果直接把用户提交的业务数据存储在<code>Redis</code>当中，把<code>Redis</code>作为数据库来使用，在其放存储重要业务数据，那么<code>Redis</code>的内存数据丢失所造成的影响也许是毁灭性。</p><p>为了避免内存中数据丢失，<code>Redis</code>提供了对持久化的支持，我们可以选择不同的方式将数据从内存中保存到硬盘当中，使数据可以持久化保存。</p><p><img src="/assets%5Cimg%5C16b9148bc2eb53a5" alt="img"></p><p><code>Redis</code>提供了<code>RDB</code>和<code>AOF</code>两种不同的数据持久化方式，下面我们就来详细介绍一下这种不同的持久化方式吧。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p><code>RDB</code>是一种快照存储持久化方式，具体就是将<code>Redis</code>某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为<code>dump.rdb</code>，而在<code>Redis</code>服务器启动时，会重新加载<code>dump.rdb</code>文件的数据到内存当中恢复数据。</p><h4 id="开启RDB持久化方式"><a href="#开启RDB持久化方式" class="headerlink" title="开启RDB持久化方式"></a>开启RDB持久化方式</h4><p>开启<code>RDB</code>持久化方式很简单，客户端可以通过向<code>Redis</code>服务器发送<code>save</code>或<code>bgsave</code>命令让服务器生成<code>rdb</code>文件，或者通过服务器配置文件指定触发<code>RDB</code>条件。</p><h5 id="1-save命令"><a href="#1-save命令" class="headerlink" title="1. save命令"></a>1. save命令</h5><p><code>save</code>命令是一个同步操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 同步数据到磁盘上</span><br><span class="line">&gt; save </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/assets%5Cimg%5C16b914a74a0c8ef5" alt="img"></p><p>当客户端向服务器发送<code>save</code>命令请求进行持久化时，服务器会阻塞<code>save</code>命令之后的其他客户端的请求，直到数据同步完成。</p><blockquote><p>如果数据量太大，同步数据会执行很久，而这期间Redis服务器也无法接收其他请求，所以，最好不要在生产环境使用<code>save</code>命令。</p></blockquote><h5 id="2-bgsave"><a href="#2-bgsave" class="headerlink" title="2. bgsave"></a>2. bgsave</h5><p>与<code>save</code>命令不同，<code>bgsave</code>命令是一个异步操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 异步保存数据集到磁盘上</span><br><span class="line">&gt; bgsave</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/assets%5Cimg%5C16b914b543343855" alt="img"></p><p>当客户端发服务发出<code>bgsave</code>命令时，<code>Redis</code>服务器主进程会<code>forks</code>一个子进程来数据同步问题，在将数据保存到rdb文件之后，子进程会退出。</p><p>所以，与<code>save</code>命令相比，<code>Redis</code>服务器在处理<code>bgsave</code>采用子线程进行IO写入，而主进程仍然可以接收其他请求，但<code>forks</code>子进程是同步的，所以<code>forks</code>子进程时，一样不能接收其他请求，这意味着，如果forks一个子进程花费的时间太久(一般是很快的)，bgsave命令仍然有阻塞其他客户的请求的情况发生。</p><blockquote></blockquote><h5 id="3-服务器配置自动触发"><a href="#3-服务器配置自动触发" class="headerlink" title="3. 服务器配置自动触发"></a>3. 服务器配置自动触发</h5><p>除了通过客户端发送命令外，还有一种方式，就是在<code>Redis</code>配置文件中的<code>save</code>指定到达触发RDB持久化的条件，比如【多少秒内至少达到多少写操作】就开启<code>RDB</code>数据同步。</p><p>例如我们可以在配置文件redis.conf指定如下的选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 900s内至少达到一条写命令</span><br><span class="line">save 900 1</span><br><span class="line"># 300s内至少达至10条写命令</span><br><span class="line">save 300 10</span><br><span class="line"># 60s内至少达到10000条写命令</span><br><span class="line">save 60 10000</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>之后在启动服务器时加载配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 启动服务器加载配置文件</span><br><span class="line">redis-server redis.conf</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这种通过服务器配置文件触发RDB的方式，与bgsave命令类似，达到触发条件时，会forks一个子进程进行数据同步，不过最好不要通过这方式来触发RDB持久化，因为设置触发的时间太短，则容易频繁写入rdb文件，影响服务器性能，时间设置太长则会造成数据丢失。</p><h4 id="rdb文件"><a href="#rdb文件" class="headerlink" title="rdb文件"></a>rdb文件</h4><p>前面介绍了三种让服务器生成rdb文件的方式，无论是由主进程生成还是子进程来生成，其过程如下：</p><ol><li>生成临时rdb文件，并写入数据。</li><li>完成数据写入，用临时文代替代正式rdb文件。</li><li>删除原来的db文件。</li></ol><p>RDB默认生成的文件名为dump.rdb，当然，我可以通过配置文件进行更加详细配置，比如在单机下启动多个redis服务器进程时，可以通过端口号配置不同的rdb名称，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 是否压缩rdb文件</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># rdb文件的名称</span><br><span class="line">dbfilename redis-6379.rdb</span><br><span class="line"></span><br><span class="line"># rdb文件保存目录</span><br><span class="line">dir ~/redis/</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="RDB的几个优点"><a href="#RDB的几个优点" class="headerlink" title="RDB的几个优点"></a>RDB的几个优点</h4><ol><li>与AOF方式相比，通过rdb文件恢复数据比较快。</li><li>rdb文件非常紧凑，适合于数据备份。</li><li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li></ol><h4 id="RDB的几个缺点"><a href="#RDB的几个缺点" class="headerlink" title="RDB的几个缺点"></a>RDB的几个缺点</h4><ol><li>如果服务器宕机的话，采用<code>RDB</code>的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li><li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>聊完了<code>RDB</code>,来聊聊<code>Redis</code>的另外一个持久化方式：<code>AOF(Append-only file)</code>。</p><p>与<code>RDB</code>存储某个时刻的快照不同，<code>AOF</code>持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以<code>Redis</code>协议追加保存到以后缀为<code>aof</code>文件末尾，在Redis服务器重启时，会加载并运行<code>aof</code>文件的命令，以达到恢复数据的目的。</p><p><img src="/assets%5Cimg%5C16b916ccf4224ec3" alt="img"></p><h4 id="开启AOF持久化方式"><a href="#开启AOF持久化方式" class="headerlink" title="开启AOF持久化方式"></a>开启AOF持久化方式</h4><p>Redis默认不开启AOF持久化方式，我们可以在配置文件中开启并进行更加详细的配置，如下面的redis.conf文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 开启aof机制</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># aof文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或no</span><br><span class="line">appendfsync always</span><br><span class="line"></span><br><span class="line"># 默认不重写aof文件</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 保存目录</span><br><span class="line">dir ~/redis/</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="三种写入策略"><a href="#三种写入策略" class="headerlink" title="三种写入策略"></a>三种写入策略</h4><p>在上面的配置文件中，我们可以通过<code>appendfsync</code>选项指定写入策略,有三个选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always</span><br><span class="line"># appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="1-always"><a href="#1-always" class="headerlink" title="1. always"></a>1. always</h5><p>客户端的每一个写操作都保存到<code>aof</code>文件当，这种策略很安全，但是每个写请注都有IO操作，所以也很慢。</p><h5 id="2-everysec"><a href="#2-everysec" class="headerlink" title="2. everysec"></a>2. everysec</h5><p><code>appendfsync</code>的默认写入策略，每秒写入一次<code>aof</code>文件，因此，最多可能会丢失1s的数据。</p><h5 id="3-no"><a href="#3-no" class="headerlink" title="3. no"></a>3. no</h5><p><code>Redis</code>服务器不负责写入<code>aof</code>，而是交由操作系统来处理什么时候写入<code>aof</code>文件。更快，但也是最不安全的选择，不推荐使用。</p><h4 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h4><p>AOF将客户端的每一个写操作都追加到<code>aof</code>文件末尾，比如对一个key多次执行incr命令，这时候，<code>aof</code>保存每一次命令到aof文件中，aof文件会变得非常大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">incr num 1</span><br><span class="line">incr num 2</span><br><span class="line">incr num 3</span><br><span class="line">incr num 4</span><br><span class="line">incr num 5</span><br><span class="line">incr num 6</span><br><span class="line">...</span><br><span class="line">incr num 100000</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决这个问题，Redis支持aof文件重写，通过重写aof，可以生成一个恢复当前数据的最少命令集，比如上面的例子中那么多条命令，可以重写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set num 100000</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>aof文件是一个二进制文件，并不是像上面的例子一样，直接保存每个命令，而使用Redis自己的格式，上面只是方便演示。</p></blockquote><h5 id="两种重写方式"><a href="#两种重写方式" class="headerlink" title="两种重写方式"></a>两种重写方式</h5><p>通过在redis.conf配置文件中的选项no-appendfsync-on-rewrite可以设置是否开启重写，这种方式会在每次fsync时都重写，影响服务器性以，因此默认值为no，不推荐使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 默认不重写aof文件</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>客户端向服务器发送bgrewriteaof命令，也可以让服务器进行AOF重写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 让服务器异步重写追加aof文件命令</span><br><span class="line">&gt; bgrewriteaof</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>AOF重写方式也是异步操作，即如果要写入aof文件，则Redis主进程会forks一个子进程来处理，如下所示：</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="655" height="250"/>)</p><h5 id="重写aof文件的好处"><a href="#重写aof文件的好处" class="headerlink" title="重写aof文件的好处"></a>重写aof文件的好处</h5><ol><li>压缩aof文件，减少磁盘占用量。</li><li>将aof的命令压缩为最小命令集，加快了数据恢复的速度。</li></ol><h4 id="AOF文件损坏"><a href="#AOF文件损坏" class="headerlink" title="AOF文件损坏"></a>AOF文件损坏</h4><p>在写入aof日志文件时，如果Redis服务器宕机，则aof日志文件文件会出格式错误，在重启Redis服务器时，Redis服务器会拒绝载入这个aof文件，可以通过以下步骤修复aof并恢复数据。</p><ol><li>备份现在aof文件，以防万一。</li><li>使用redis-check-aof命令修复aof文件，该命令格式如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 修复aof日志文件</span><br><span class="line">$ redis-check-aof -fix file.aof</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>重启Redis服务器，加载已经修复的aof文件，恢复数据。</li></ol><h4 id="AOF的优点"><a href="#AOF的优点" class="headerlink" title="AOF的优点"></a>AOF的优点</h4><p>AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</p><h4 id="AOF的缺点"><a href="#AOF的缺点" class="headerlink" title="AOF的缺点"></a>AOF的缺点</h4><ol><li>AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。</li><li>恢复数据的速度比RDB慢。</li></ol><h3 id="选择RDB还是AOF呢？"><a href="#选择RDB还是AOF呢？" class="headerlink" title="选择RDB还是AOF呢？"></a>选择RDB还是AOF呢？</h3><p>通过上面的介绍，我们了解了RDB与AOF各自的优点与缺点，到底要如何选择呢？</p><p>通过下面的表示，我们可以从几个方面对比一下RDB与AOF,在应用时，要根本自己的实际需求，选择RDB或者AOF，其实，如果想要数据足够安全，可以两种方式都开启，但两种持久化方式同时进行IO操作，会严重影响服务器性能，因此有时候不得不做出选择。</p><p><img src="/assets%5Cimg%5C16b918cd860b0ffd" alt="img"></p><p>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面讲了一大堆<code>Redis</code>的持久化机制的知识，其实，如果你只是单纯把<code>Redis</code>作为缓存服务器，那么可以完全不用考虑持久化，但是，在如今的大多数服务器架构中，<code>Redis</code>的单单只是扮演一个缓存服务器的角色，还可以作为数据库，保存我们的业务数据，此时，我们则需要好好了解有关<code>Redis</code>持久化策略的区别与选择。</p><p>作者：张君鸿链接：<a href="https://juejin.im/post/5d09a9ff51882577eb133aa9来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。" target="_blank" rel="noopener">https://juejin.im/post/5d09a9ff51882577eb133aa9来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis内存数据的淘汰机制&quot;&gt;&lt;a href=&quot;#Redis内存数据的淘汰机制&quot; class=&quot;headerlink&quot; title=&quot;Redis内存数据的淘汰机制&quot;&gt;&lt;/a&gt;Redis内存数据的淘汰机制&lt;/h2&gt;&lt;p&gt;​    Redis内存淘汰指的是用户存储的一些键被可以被Redis主动地从实例中删除，从而产生读miss的情况.&lt;br&gt;​    内存的淘汰机制的初衷是为了更好地使用内存，用一定的缓存miss来换取内存的使用效率.&lt;br&gt;存入数据时,指定有效时间&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>数据库三大范式</title>
    <link href="http://yoursite.com/2019/11/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/11/12/数据库三大范式/</id>
    <published>2019-11-12T08:30:30.000Z</published>
    <updated>2019-11-19T01:30:21.783Z</updated>
    
    <content type="html"><![CDATA[<p>数据库设计阶段:</p><p>​    1.需求分析:收集信息,要存储的数据,E-R图(实体关系图)<br>​    2.概要设计:数据库模型图<br>​    3.详细设计:使用三大范式,规范数据库设计<br>​    4.编码:数据库实现</p><h1 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h1><p>这里用的是Visio2003</p><p>E-R图分为对象(矩形),属性(椭圆),关系(菱形) 三个主要部分</p><p><img src="/assets%5Cimg%5Cimage-20191114103144368.png" alt="image-20191114103144368"></p><p>实体之间的映射基数:一对一,一对多,多对一,多对多</p><h1 id="数据库模型图"><a href="#数据库模型图" class="headerlink" title="数据库模型图"></a>数据库模型图</h1><p><img src="/assets%5Cimg%5Cimage-20191114110239970.png" alt="image-20191114110239970"></p><h1 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h1><p>基本完全参考 <a href="https://segmentfault.com/a/1190000013695030" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013695030</a> </p><p>三大范式是规范数据库设计的最小要求</p><h2 id="一、第一范式"><a href="#一、第一范式" class="headerlink" title="一、第一范式"></a>一、第一范式</h2><p>1NF是对属性的<strong><code>原子性</code></strong>，要求属性具有原子性，不可再分解；</p><blockquote><p>表：字段1、 字段2(字段2.1、字段2.2)、字段3 ……</p></blockquote><p>如学生（学号，姓名，性别，出生年月日），如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不是一范式了，否则就是；具体问题具体分析</p><h2 id="二、第二范式"><a href="#二、第二范式" class="headerlink" title="二、第二范式"></a>二、第二范式</h2><p>2NF是对记录的<strong><code>惟一性</code></strong>，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；</p><blockquote><p>表：学号、课程号、姓名、学分;</p></blockquote><p>这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里<strong>学分依赖课程号</strong>，<strong>姓名依赖与学号</strong>，所以不符合二范式。</p><p><strong>可能会存在问题：</strong></p><ul><li><code>数据冗余:</code>，每条记录都含有相同信息；</li><li><code>删除异常：</code>删除所有学生成绩，就把课程信息全删除了；</li><li><code>插入异常：</code>学生未选课，无法记录进数据库；</li><li><code>更新异常：</code>调整课程学分，所有行都调整。</li></ul><p><strong>正确做法:</strong><br>学生：<code>Student</code>(学号, 姓名)；<br>课程：<code>Course</code>(课程号, 学分)；<br>选课关系：<code>StudentCourse</code>(学号, 课程号, 成绩)。</p><h2 id="三、第三范式"><a href="#三、第三范式" class="headerlink" title="三、第三范式"></a>三、第三范式</h2><p>3NF是对字段的<strong><code>冗余性</code></strong>，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</p><blockquote><p>表: 学号, 姓名, 年龄, 学院名称, 学院电话</p></blockquote><p>因为存在<strong>依赖传递</strong>: (学号) → (学生)→(所在学院) → (学院电话) 。</p><p><strong>可能会存在问题：</strong></p><ul><li><code>数据冗余:</code>有重复值；</li><li><code>更新异常：</code>有重复的冗余信息，修改时需要同时修改多条记录，否则会出现<strong>数据不一致的情况</strong> 。</li></ul><p><strong>正确做法：</strong></p><p>学生：(学号, 姓名, 年龄, 所在学院)；</p><p>学院：(学院, 电话)。</p><h2 id="四、反范式化"><a href="#四、反范式化" class="headerlink" title="四、反范式化"></a>四、反范式化</h2><p><strong>一般说来，数据库只需满足第三范式（<code>3NF</code>）就行了。</strong></p><p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，<strong><code>达到以空间换时间的目的</code></strong>。</p><p>〖例〗：有一张存放商品的基本表，如表1所示。“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</p><p>在<code>Rose 2002</code>中，规定列有两种类型：<strong>数据列</strong>和<strong>计算列</strong>。“金额”这样的列被称为“计算列”，而“单价”和“数量”这样的列被称为“数据列”。</p><h2 id="五、范式化设计和反范式化设计的优缺点"><a href="#五、范式化设计和反范式化设计的优缺点" class="headerlink" title="五、范式化设计和反范式化设计的优缺点"></a>五、范式化设计和反范式化设计的优缺点</h2><h3 id="5-1-范式化"><a href="#5-1-范式化" class="headerlink" title="5.1 范式化"></a>5.1 范式化</h3><p><strong>优点：</strong></p><p><img src="/assets%5Cimg%5C1291265419-5aa76970ab29f_articlex.png" alt="clipboard.png"></p><p><strong>缺点：</strong></p><p><img src="/assets%5Cimg%5C3541584523-5aa76a12393b0_articlex.png" alt="clipboard.png"></p><h3 id="5-2-反范式化"><a href="#5-2-反范式化" class="headerlink" title="5.2 反范式化"></a>5.2 反范式化</h3><p><strong>优点：</strong></p><p><img src="/assets%5Cimg%5C3600099256-5aa76b36084c1_articlex.png" alt="clipboard.png"></p><p><strong>缺点：</strong></p><p><img src="/assets%5Cimg%5C1354236810-5aa76b65a1bcd_articlex.png" alt="clipboard.png"></p><p><strong>参考资料如下：</strong></p><p><a href="http://blog.csdn.net/taorui/article/details/2418761" target="_blank" rel="noopener">1、通俗地理解数据库三个范式</a><br><a href="http://blog.csdn.net/wuyanxiaxia/article/details/22933021" target="_blank" rel="noopener">2、数据库模型设计，第一范式、第二范式、第三范式简单例子理解</a><br><a href="http://blog.csdn.net/andywuchuanlong/article/details/25913235" target="_blank" rel="noopener">3、数据库三大范式最简单的解释</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库设计阶段:&lt;/p&gt;
&lt;p&gt;​    1.需求分析:收集信息,要存储的数据,E-R图(实体关系图)&lt;br&gt;​    2.概要设计:数据库模型图&lt;br&gt;​    3.详细设计:使用三大范式,规范数据库设计&lt;br&gt;​    4.编码:数据库实现&lt;/p&gt;
&lt;h1 id=&quot;E-
      
    
    </summary>
    
    
    
      <category term="DB" scheme="http://yoursite.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>redis-哨兵模式及Java中的使用</title>
    <link href="http://yoursite.com/2019/11/12/redis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%8F%8AJava%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/11/12/redis-哨兵模式及Java中的使用/</id>
    <published>2019-11-12T01:40:30.000Z</published>
    <updated>2019-11-19T01:30:02.707Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://www.jianshu.com/p/06ab9daf921d" target="_blank" rel="noopener">https://www.jianshu.com/p/06ab9daf921d</a> </p><p>看看这个 <a href="https://www.jianshu.com/p/06ab9daf921d" target="_blank" rel="noopener">https://www.jianshu.com/p/06ab9daf921d</a> </p><a id="more"></a><h2 id="6-哨兵模式"><a href="#6-哨兵模式" class="headerlink" title="6. 哨兵模式"></a>6. 哨兵模式</h2><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p><p><img src="/assets%5Cimg%5C11320039.png" alt="Redis哨兵"></p><p>Redis哨兵</p><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p>用文字描述一下<strong>故障切换（failover）</strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先配置Redis的主从服务器，修改redis.conf文件如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使得Redis服务器可以跨网络访问</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">requirepass <span class="string">"123456"</span></span><br><span class="line"><span class="comment"># 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line">slaveof 192.168.11.128 6379</span><br><span class="line"><span class="comment"># 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><p>复制安装包中sentinel.conf 到redis的bin目录</p><p>修改sentinel.conf(没有的话新建一个)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">port 26380</span><br><span class="line"></span><br><span class="line">声明该Sentinel监控的master的名字叫做mymaster，地址为127.0.0.1，最后一个1表示的意思是当集群中有1个Sentinel认为master宕机了或者1个Sentinel有1次认为master宕机了，就会真正认为该master彻底宕机了。</span><br><span class="line"><span class="comment">#sentinel monitor master-name host port quorum</span></span><br><span class="line">sentinel montior mymaster 127.0.0.1 6381 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#Sentinel会向master发送心跳PING来确认master是否运行，如果master在一定时间（down-after-milliseconds，单位毫秒）内不回应PONG 或者是回复了一个错误消息，那么Sentinel会认为master已经宕机了。</span></span><br><span class="line"><span class="comment">#sentinel down-after-milliseconds master-name milliseconds</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果监控的Redis服务器设置了密码，这需要配置这个选项</span></span><br><span class="line"><span class="comment">#sentinel down-after-milliseconds master-name milliseconds</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选项指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步， 这个数字越小， 完成故障转移所需的时间就越长。</span></span><br><span class="line">sentinel config-epoch mymaster 12</span><br><span class="line">sentinel leader-epoch mymaster 13</span><br><span class="line"></span><br><span class="line"><span class="comment">#failover（提升一个slave成为master）过期时间，如果超过这个时间没触发成功failover，sentinel会认为failover失败。</span></span><br><span class="line"><span class="comment">#sentinel failover-timeout mymaster 30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当failover时，可以指定一个“通知”脚本用来告知当前集群的情况。</span></span><br><span class="line"><span class="comment">#脚本被允许执行的最大时间为60秒，如果超时，脚本将会被终止(KILL)</span></span><br><span class="line"><span class="comment">#sentinel notification-script mymaster /var/redis/notify.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#failover之后重配置客户端</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br></pre></td></tr></table></figure><p><img src="G:/blog/source/assets/img/1556290917564.png" alt="1556290917564"></p><p>第一行的配置 sentinel monitor mymaster 127.0.0.1 6382 1</p><p>是创建了一个叫mymaster的服务器，这个名字是自己定义的。后面哨兵配置中的&lt;服务器名&gt;对应的就是这个值。127.0.01 6382是主服务器的地址和端口，后面的1是要判断这个主服务器失效，至少要1个哨兵同意。</p><p>哨兵的配置：</p><p>sentinel &lt;选项名&gt; &lt;服务器名&gt; &lt;选项值&gt;</p><p>选项：</p><p>down-after-milliseconds： 指定哨兵认为服务器断线所需要的毫秒数</p><p>parallel-sync：s 指定了在执行故障转译时，最多可以有多少个从服务器同时对主服务器进行同步，数值越小，完成故障转移的时间越长</p><p>failover-timeout：实现主从切换，完成故障转移的所需要的最大时间值。若Sentinel（哨兵）进程在该配置值内未能完成故障转移的操作（即故障时master/slave自动切换），则认为本次故障转移操作失败。</p><p>notification-script: 指定Sentinel（哨兵）进程检测到Master-Name所指定的“Master主服务器”的实例异常的时候，所要调用的报警脚本。该配置项可选，但线上系统建议配置。</p><p>以哨兵模式开启</p><p>./redis-server sentinel.conf –sentinel</p><p><img src="G:/blog/source/assets/img/1556290944485.png" alt="1556290944485"></p><p>关闭主节点，会看到哨兵重新选择了主节点</p><p>哨兵支持集群</p><p>注意：故障切换的两个条件：</p><p>1.quorum个哨兵发现master不可用</p><p>2.半数以上的哨兵可用，一个哨兵需要获得多数哨兵的支持才能迁移，只有少数哨兵运行的情况下，即使达到quorum个，也无法迁移。</p><p>1)：每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令<br> 2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。<br> 3)：如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。<br> 4)：当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线<br> 5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令<br> 6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次<br> 7)：若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 </p><p>8)：若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</p><p>下面我们来解释一下两个“下线”的概念，一个是“主观下线”，另一个就是“客观下线”。</p><p><strong>主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</strong></p><p><strong>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的服务器下线判断。（一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）</strong></p><p>如果一个服务器没有在 master-down-after-milliseconds 选项所指定的时间内，对向它发送 PING 命令的 Sentinel（哨兵）进程返回一个有效回复（valid reply），那么Sentinel（哨兵）进程就会将这个服务器标记为主观下线。</p><p>服务器对 PING 命令的有效回复可以是以下三种回复的其中一种：</p><p>1、返回 +PONG 。</p><p>2、返回 -LOADING错误。</p><p>3、返回 -MASTERDOWN错误。</p><p>如果服务器返回除以上三种回复之外的其他回复，又或者在指定时间内没有回复 PING 命令，那么 Sentinel（哨兵）进程认为服务器返回的回复无效（non-valid）。</p><p>如果一个服务器在 master-down-after-milliseconds 毫秒内，一直返回无效回复才会被 Sentinel 标记为主观下线。</p><p>举个例子，如果 master-down-after-milliseconds 选项的值为 30000 毫秒（30 秒），那么只要服务器能在每 29 秒之内返回至少一次有效回复， 这个服务器就仍然会被认为是处于正常状态的。</p><p><strong>从“主观下线”状态切换到“客观下线”状态并没有使用严格的法定人数算法（strong quorum algorithm），而是使用了流言协议，该协议解释为：如果 Sentinel（哨兵）进程在给定的时间范围内，从其他 Sentinel（哨兵）进程那里接收到了足够数量的主服务器下线报告， 那么 Sentinel（哨兵）进程就会将主服务器的状态从“主观下线”改变为“客观下线”。如果之后其他 Sentinel（哨兵）进程不再报告主服务器已下线，那么“客观下线”状态就会被移除。</strong></p><p>  “客观下线”条件只适用于主服务器：对于任何其他类型的 Redis 实例， Sentinel（哨兵）进程在将它们判断为下线前不需要进行协商，所以Slave从服务器或者其他 Sentinel（哨兵）进程永远不会达到“客观下线”条件。**</p><p><strong>只要有一个 Sentinel（哨兵）进程发现某个主服务器进入了“客观下线”状态，这个 Sentinel（哨兵）进程就可能会被其他 Sentinel（哨兵）进程推选出，并对失效的主服务器执行自动故障迁移操作。</strong></p><p><strong>一个哨兵与其它哨兵进行连接，各个哨兵之间可以互相检查对方的可用性，并进行信息交换。我们不需要设置每个哨兵之间的关系。哨兵之间是通过发布订阅功能来自动发现正在监视相同主服务器的哨兵。</strong></p><p><strong>哨兵模式的优缺点</strong></p><p><strong>优点：</strong></p><p>1、哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。</p><p>2、主从可以切换，故障可以转移，系统可用性更好。</p><p>3、哨兵模式是主从模式的升级，系统更健壮，可用性更高。</p><p><strong>缺点：</strong></p><p>1、Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</p><h2 id="7-集群"><a href="#7-集群" class="headerlink" title="7.集群"></a>7.集群</h2><p>​        注意安装集群的时候要求每个节点都是空的。所以不要复制以前的redis，最好重新安装一个。</p><p>​        创建集群目录redis-cluster</p><p>​        Redis集群中应该有奇数个节点，所以至少应该有三个节点，如果其中的一个节点挂掉，集群将不能访问。redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。如果一个主节点和它所有的从节点都挂掉了，那集群也就不能正常的服务了。</p><p>​        Redis集群至少需要6台服务器。搭建伪分布式。可以使用一台虚拟机运行6个redis实例。需要修改redis的端口号7001-7006</p><p><img src="G:/blog/source/assets/img/1556291090820.png" alt="1556291090820"></p><p>配置文件中还需要把cluster相关配置前的注释去掉</p><p><img src="G:/blog/source/assets/img/1556291112646.png" alt="1556291112646"></p><p>保存并退出</p><p>在redis-cluster目录下，将redis01复制5份</p><p><img src="G:/blog/source/assets/img/1556291129310.png" alt="1556291129310"></p><p>分别修改redis02-redis06的端口为7002-7006</p><p>启动每个redis。最好提前都ping一下每个节点。</p><p>可以在redis-cluster目录下创建启动集群的脚本：start-cluster.sh</p><p><code>cd redis01/bin</code></p><p><code>./redis-server redis.conf</code></p><p><code>cd ../../redis02/bin</code></p><p><code>./redis-server redis.conf</code></p><p><code>cd ../../redis03/bin</code></p><p><code>./redis-server redis.conf</code></p><p><code>cd ../../redis04/bin</code></p><p><code>./redis-server redis.conf</code></p><p><code>cd ../../redis05/bin</code></p><p><code>./redis-server redis.conf</code></p><p><code>cd ../../redis06/bin</code></p><p><code>./redis-server redis.conf</code></p><p><code>cd ../../</code></p><p>授权chmod u+x start-cluster.sh</p><p>(u是自己，x是可执行)</p><p>查看运行状态：</p><p><img src="G:/blog/source/assets/img/1556291157795.png" alt="1556291157795"></p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>./redis-cli –cluster create<br>10.9.63.181:7001 10.9.63.181:7002 10.9.63.181:7003 10.9.63.181:7004<br>10.9.63.181:7005 10.9.63.181:7006<br>–cluster-replicas 1</p><p>其中主机ip不能使用内网ip或者127.0.0.1，否则远程无法连接集群。这里不支持域名。</p><p><img src="G:/blog/source/assets/img/1556291378321.png" alt="1556291378321">                                                  </p><p>如果集群创建失败了，需要把每个节点下的集群文件删除才能再次创建：</p><p><img src="G:/blog/source/assets/img/1556291400226.png" alt="1556291400226"></p><p>测试连接：</p><p>./redis-cli  -p 7002 -c</p><p>其中-c代表集群</p><p>cluster info       打印集群的信息<br> cluster nodes   列出集群当前已知的所有节点(node)，以及这些节点的相关信息</p><p><img src="G:/blog/source/assets/img/1556291423723.png" alt="1556291423723"></p><p>创建停止集群的脚本stop-cluster.sh：</p><p><code>redis01/bin/redis-cli -p 7001 shutdown</code></p><p><code>redis01/bin/redis-cli -p 7002 shutdown</code></p><p><code>redis01/bin/redis-cli -p 7003 shutdown</code></p><p><code>redis01/bin/redis-cli -p 7004 shutdown</code></p><p><code>redis01/bin/redis-cli -p 7005 shutdown</code></p><p><code>redis01/bin/redis-cli -p 7006 shutdown</code></p><h3 id="追加节点"><a href="#追加节点" class="headerlink" title="追加节点"></a>追加节点</h3><p>./redis-cli –cluster add-node 10.9.63.181:7007 10.9.63.181:7001</p><p>给主节点分配槽</p><p>./redis-cli –cluster  reshard 10.9.63.181:7001</p><p>把7008变成7007的从节点</p><p>./redis-cli -c -p 7008 cluster replicate 39de4333b9faf37c22a58777655932e00b513f74</p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除从节点：</p><p>连接任意一个节点，最后一个参数是要删除的从节点id</p><p>./redis-cli –cluster del-node 127.0.0.1:7001 a06a54ab354327cd9920fa8b14a7b8b71a4d445a</p><p>删除主节点，需要先将主节点的槽移走</p><p>./redis-cli –cluster  reshard 10.9.63.181:7001</p><p><img src="G:/blog/source/assets/img/1556291691889.png" alt="1556291691889"></p><p>输入done</p><p><img src="G:/blog/source/assets/img/1556291743114.png" alt="1556291743114"></p><p><img src="G:/blog/source/assets/img/1556291758353.png" alt="1556291758353"></p><p>槽移走之后，删除主节点：</p><p>./redis-cli –cluster del-node 127.0.0.1:7001 a06a54ab354327cd9920fa8b14a7b8b71a4d445a</p><h2 id="8-JAVA操作redis"><a href="#8-JAVA操作redis" class="headerlink" title="8. JAVA操作redis"></a>8. JAVA操作redis</h2><p>Java使用Redis写数据,读缓存数据</p><p>缓存预热:提前把数据放入Redis缓存中.</p><p>java操作redis需要引入jedis的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedis</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：创建一个Jedis对象。需要指定服务端的ip及端口。</span></span><br><span class="line"></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"www.vm.com"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(jedis.ping());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：使用Jedis对象操作数据库，每个redis命令对应一个方法。</span></span><br><span class="line"></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>,<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(jedis.get(<span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：关闭Jedis</span></span><br><span class="line"></span><br><span class="line">    jedis.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>密码连接用：需要2.9.0或以上的jar包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.auth(<span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure><h3 id="集群版"><a href="#集群版" class="headerlink" title="集群版"></a>集群版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisCluster</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：需要一个Set&lt;HostAndPort&gt;参数,存放Redis节点的列表。</span></span><br><span class="line"></span><br><span class="line">    Set&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"127.0.0.1"</span>, <span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"127.0.0.1"</span>, <span class="number">7002</span>));</span><br><span class="line"></span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"127.0.0.1"</span>, <span class="number">7003</span>));</span><br><span class="line"></span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"127.0.0.1"</span>, <span class="number">7004</span>));</span><br><span class="line"></span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"127.0.0.1"</span>, <span class="number">7005</span>));</span><br><span class="line"></span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"127.0.0.1"</span>, <span class="number">7006</span>));</span><br><span class="line"></span><br><span class="line">    JedisCluster jedisCluster = <span class="keyword">new</span> JedisCluster(nodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：直接使用JedisCluster对象操作redis。在系统中单例存在。</span></span><br><span class="line"></span><br><span class="line">    System.out.println(jedisCluster.exists(<span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：系统关闭前，关闭JedisCluster对象。</span></span><br><span class="line"></span><br><span class="line">    jedisCluster.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-整合Spring"><a href="#9-整合Spring" class="headerlink" title="9.整合Spring"></a>9.整合Spring</h2><h3 id="单机版-1"><a href="#单机版-1" class="headerlink" title="单机版"></a>单机版</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPool"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPool"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"www.vm.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6379"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用密码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPool"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPool"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"www.xiaoheiben.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6379"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"30000"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpringJedis</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ApplicationContext ac =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-redis.xml"</span>);</span><br><span class="line">    <span class="comment">//获取连接池对象</span></span><br><span class="line">    JedisPool jedisPool = (JedisPool) ac.getBean(<span class="string">"jedisPool"</span>);</span><br><span class="line">    <span class="comment">//从连接池中获取连接</span></span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    System.out.println(jedis.ping());</span><br><span class="line">    System.out.println(jedis.exists(<span class="string">"hello"</span>));</span><br><span class="line">    jedis.close();<span class="comment">//关闭连接</span></span><br><span class="line">    jedisPool.close();<span class="comment">//关闭连接池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集群版-1"><a href="#集群版-1" class="headerlink" title="集群版"></a>集群版</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 集群版的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisCluster"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisCluster"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"127.0.0.1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"7001"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"127.0.0.1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"7002"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"127.0.0.1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"7003"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"127.0.0.1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"7004"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"127.0.0.1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"7005"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"127.0.0.1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"7006"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>带密码的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisCluster"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisCluster"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"jedisClusterNode"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"10.0.107.156"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6381"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"10.0.107.156"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6382"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"10.0.107.156"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6383"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"10.0.107.156"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6384"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"10.0.107.156"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6385"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"10.0.107.156"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6386"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"connectionTimeout"</span> <span class="attr">value</span>=<span class="string">"3000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"soTimeout"</span> <span class="attr">value</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"maxAttempts"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpringJedisCluster</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ac =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-redis.xml"</span>);</span><br><span class="line">    JedisCluster jedisCluster = (JedisCluster)ac.getBean(<span class="string">"jedisCluster"</span>);</span><br><span class="line">    System.out.println(jedisCluster.exists(<span class="string">"hello"</span>));</span><br><span class="line">    jedisCluster.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line">## Redis服务器地址</span><br><span class="line">spring.redis.host=www.vm.com</span><br><span class="line">## Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">## Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=123456</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(num, code);</span><br></pre></td></tr></table></figure><p>解决中文乱码的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">// key序列化</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        <span class="comment">//val实例化</span></span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集群版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##服务器</span><br><span class="line">spring.redis.cluster.nodes=192.168.159.129:7001,192.168.159.129:7002,192.168.159.129:7003,192.168.159.129:7004,192.168.159.129:7005,192.168.159.129:7006</span><br><span class="line">### 连接超时时间（毫秒） </span><br><span class="line">spring.redis.timeout=60000</span><br></pre></td></tr></table></figure><h2 id="10-REsp协议"><a href="#10-REsp协议" class="headerlink" title="10. REsp协议"></a>10. REsp协议</h2><p>Redis服务器与客户端通过RESP（REdis Serialization Protocol）协议通信。是基于TCP的应用层协议。Redis在TCP的6379端口监听连接，本质是Socket。</p><p>RESP协议的特点：容易实现、解析快、人类可读。</p><p>使用Socket模拟一个Redis服务端，看一下Redis客户端进行通信时的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream input = <span class="keyword">null</span>;<span class="comment">// 用于读取别人发过来的消息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            input = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = input.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(arr, <span class="number">0</span>, len);</span><br><span class="line">                System.out.print(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                input.close();</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为6379是redis端口，所以换一个8888端口，让redis客户端请求到我们的Socket上。</p><p>运行redis客户端：</p><p><img src="G:/blog/source/assets/img/1556292026498.png" alt="1556292026498"></p><p>看我们的Socket中收到的信息：</p><p><code>*1</code></p><p><code>$7</code></p><p><code>COMMAND</code></p><p>代表我们的模拟服务端成功了。使用java的Jedis访问，执行set命令：</p><p>(注意在运行的时候会报错，因为不是真正的redis服务端，无法给出正确的响应，能读取到命令即可)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>, <span class="number">8888</span>);</span><br><span class="line">        jedis.set(<span class="string">"hello"</span>, <span class="string">"123"</span>);</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看收到的信息：</p><p><code>*3</code></p><p><code>$3</code></p><p><code>SET</code></p><p><code>$5</code></p><p><code>hello</code></p><p><code>$3</code></p><p><code>123</code></p><p>可以发现命令的共同点，“*”号，“$”,一些数字，及命令中的key和value</p><p>解读一下：</p><p>*3         //后面存在几个$</p><p>$3         //后面字符串的长度</p><p>SET         //SET是三个字符，对应上一行的$3</p><p>$5           //下一行是5个字符</p><p>hello       //hello是五个字符，对应上一行的$5</p><p>$3</p><p>123</p><p>在控制台打印的时候命令自动换行了，是因为命令中间自带换行符“\r\n”</p><p>接收到的完整命令是：</p><p>*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$3\r\n123\r\n</p><p>现在可以手写Redis客户端，看服务端的回复：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">        InputStream input = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">"10.199.0.112"</span>, <span class="number">6379</span>);</span><br><span class="line">            output = socket.getOutputStream();</span><br><span class="line">            output.write(<span class="string">"*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$3\r\nabc\r\n"</span>.getBytes());</span><br><span class="line">            output.flush();</span><br><span class="line">            input = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = input.read(arr);</span><br><span class="line">            String message = <span class="keyword">new</span> String(arr, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                input.close();</span><br><span class="line">                output.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，可以看到服务端的回复：</p><p><code>+OK</code></p><p>去redis中查询：</p><p><img src="G:/blog/source/assets/img/1556292204517.png" alt="1556292204517"></p><h2 id="11-分布式锁"><a href="#11-分布式锁" class="headerlink" title="11. 分布式锁"></a>11. 分布式锁</h2><p>redis中设置库存20：</p><p><img src="D:%5C%E5%B7%A5%E4%BD%9C%5C%E5%8D%83%E9%94%8B%E6%95%99%E8%82%B2%5C%E6%95%99%E6%A1%88%E6%96%87%E6%A1%A3%5C%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3%5C%E5%9B%9B%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%5C13-%E9%94%81%5C1554460281853.png" alt="1554460281853"></p><p>不加锁的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> num = i % <span class="number">3</span> + <span class="number">1</span>;<span class="comment">//模拟随机购买数量</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                unlockBuy(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlockBuy</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String name=Thread.currentThread().getName();</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">    String amount = jedis.get(<span class="string">"amount"</span>);</span><br><span class="line">    System.out.println(name+<span class="string">"查询库存"</span>+amount);</span><br><span class="line">    <span class="keyword">if</span> (Integer.parseInt(amount) &gt;= num) &#123;<span class="comment">//判断剩余的数量</span></span><br><span class="line">        Long stock = jedis.decrBy(<span class="string">"amount"</span>, num);<span class="comment">//减库存</span></span><br><span class="line">        System.out.println(name+<span class="string">"购买"</span>+num+<span class="string">"后剩余"</span> + stock);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"购买失败，库存不足"</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果（注：线程运行具有随机性，每次测试结果可能不同）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">11</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">5</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">19</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">10</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">12</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">2</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">4</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">18</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">6</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">1</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">14</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">9</span>查询库存<span class="number">20</span></span><br><span class="line">Thread-<span class="number">15</span>查询库存<span class="number">6</span></span><br><span class="line">Thread-<span class="number">3</span>查询库存<span class="number">2</span></span><br><span class="line">Thread-<span class="number">17</span>查询库存-<span class="number">3</span></span><br><span class="line">Thread-<span class="number">13</span>查询库存-<span class="number">3</span></span><br><span class="line">Thread-<span class="number">17</span>购买失败，库存不足<span class="number">3</span></span><br><span class="line">Thread-<span class="number">13</span>购买失败，库存不足<span class="number">2</span></span><br><span class="line">Thread-<span class="number">15</span>购买<span class="number">1</span>后剩余-<span class="number">5</span></span><br><span class="line">Thread-<span class="number">6</span>购买<span class="number">1</span>后剩余<span class="number">2</span></span><br><span class="line">Thread-<span class="number">18</span>购买<span class="number">1</span>后剩余<span class="number">3</span></span><br><span class="line">Thread-<span class="number">1</span>购买<span class="number">2</span>后剩余<span class="number">0</span></span><br><span class="line">Thread-<span class="number">5</span>购买<span class="number">3</span>后剩余<span class="number">14</span></span><br><span class="line">Thread-<span class="number">14</span>购买<span class="number">3</span>后剩余-<span class="number">3</span></span><br><span class="line">Thread-<span class="number">19</span>购买<span class="number">2</span>后剩余<span class="number">10</span></span><br><span class="line">Thread-<span class="number">9</span>购买<span class="number">1</span>后剩余-<span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>查询库存-<span class="number">5</span></span><br><span class="line">Thread-<span class="number">7</span>查询库存-<span class="number">5</span></span><br><span class="line">Thread-<span class="number">8</span>查询库存-<span class="number">5</span></span><br><span class="line">Thread-<span class="number">10</span>购买<span class="number">2</span>后剩余<span class="number">12</span></span><br><span class="line">Thread-<span class="number">12</span>购买<span class="number">1</span>后剩余<span class="number">9</span></span><br><span class="line">Thread-<span class="number">11</span>购买<span class="number">3</span>后剩余<span class="number">17</span></span><br><span class="line">Thread-<span class="number">2</span>购买<span class="number">3</span>后剩余<span class="number">6</span></span><br><span class="line">Thread-<span class="number">4</span>购买<span class="number">2</span>后剩余<span class="number">4</span></span><br><span class="line">Thread-<span class="number">16</span>查询库存-<span class="number">5</span></span><br><span class="line">Thread-<span class="number">3</span>购买<span class="number">1</span>后剩余-<span class="number">6</span></span><br><span class="line">Thread-<span class="number">8</span>购买失败，库存不足<span class="number">3</span></span><br><span class="line">Thread-<span class="number">7</span>购买失败，库存不足<span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span>购买失败，库存不足<span class="number">1</span></span><br><span class="line">Thread-<span class="number">16</span>购买失败，库存不足<span class="number">2</span></span><br></pre></td></tr></table></figure><p>看redis中，</p><p><img src="D:%5C%E5%B7%A5%E4%BD%9C%5C%E5%8D%83%E9%94%8B%E6%95%99%E8%82%B2%5C%E6%95%99%E6%A1%88%E6%96%87%E6%A1%A3%5C%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3%5C%E5%9B%9B%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%5C13-%E9%94%81%5C1554460167500.png" alt="1554460167500"></p><p>库存-6，说明超了。</p><p>redis中有setnx命令，如果key不存在则能设置成功，设置成功返回1，否则返回0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lock1</span><span class="params">(String amountKey, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">    String name = Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">//如果key不存在就设置成功并返回1,否则的返回0</span></span><br><span class="line">    Long setnx = jedis.setnx(<span class="string">"lock"</span>, <span class="string">"dasdasdasd"</span>);</span><br><span class="line">    System.out.println(name + <span class="string">"设置锁"</span> + setnx);</span><br><span class="line">    <span class="comment">//判断剩余的数量</span></span><br><span class="line">    <span class="keyword">if</span> (setnx == <span class="number">1</span>) &#123;<span class="comment">//设置成功,代表拿到锁了</span></span><br><span class="line">        <span class="comment">//jedis.expire(amountKey + "lock", 1);//（1）设置有效期,防止代码异常无法释放锁</span></span><br><span class="line">        String amount = jedis.get(amountKey);<span class="comment">//库存</span></span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(amount) &gt;= num) &#123;<span class="comment">//剩余数量可以购买</span></span><br><span class="line">            Long stock = jedis.decrBy(amountKey, num);</span><br><span class="line">            System.out.println(name + <span class="string">"购买"</span> + num + <span class="string">"后剩余"</span> + stock);</span><br><span class="line">            jedis.del(amountKey + <span class="string">"lock"</span>);<span class="comment">//释放锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">"购买失败，库存不足"</span> + num);</span><br><span class="line">            jedis.del(amountKey + <span class="string">"lock"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"有人正在购买"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">18</span>设置锁<span class="number">0</span></span><br><span class="line">Thread-<span class="number">6</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">10</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">14</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">15</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">19</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">12</span>设置锁<span class="number">1</span></span><br><span class="line">Thread-<span class="number">17</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">2</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">11</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">3</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">9</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">0</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">16</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">8</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">5</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">1</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">7</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">4</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">13</span>设置锁<span class="number">0</span></span><br><span class="line">有人正在购买</span><br><span class="line">Thread-<span class="number">12</span>购买<span class="number">1</span>后剩余<span class="number">19</span></span><br></pre></td></tr></table></figure><p>没有抢到锁的线程可以稍后重试。上面的代码可以解决并发问题。但是，它不具有原子性。如果加锁成功，在释放锁之前，客户端挂掉了或者断网了，那么redis中锁的key一直存在，后续的线程都无法再获得锁。</p><p>为了解决这个问题，可以对加锁的key设置过期时间，如果使用(1)注释的代码，可能还遇到一个问题就是没等进入if执行这一句的时候，客户端掉线了，锁还是一直存在，对此进行改进，在设置key的同时就设置过期时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockWithExpire</span><span class="params">(String amountKey, <span class="keyword">int</span> num)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    String name = Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">//获取reids的链接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">//  Long setnx = jedis.setnx(amountKey+"lock", "dasdasdasd");</span></span><br><span class="line">    <span class="comment">//在设置key的时候就设置过期时间,成功返回OK,否则返回null</span></span><br><span class="line">    <span class="comment">//String setnx = jedis.set(amountKey + "lock", "dasdasdasd", "nx", "ex", 1);</span></span><br><span class="line">    String lock = jedis.set(<span class="string">"lock"</span>, name,  SetParams.setParams().nx().ex(<span class="number">1</span>));</span><br><span class="line">    System.out.println(name+<span class="string">"加锁"</span>+setnx);</span><br><span class="line">    <span class="comment">//判断剩余的数量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"OK"</span>.equals(setnx)) &#123;<span class="comment">//设置成功,代表拿到锁了</span></span><br><span class="line">        String amount = jedis.get(amountKey);<span class="comment">//库存</span></span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(amount) &gt;= num) &#123;<span class="comment">//剩余数量可以购买</span></span><br><span class="line">            Long stock = jedis.decrBy(amountKey, num);</span><br><span class="line">            System.out.println(name + <span class="string">"购买"</span> + num + <span class="string">"后剩余"</span> + stock);</span><br><span class="line">            jedis.del(amountKey + <span class="string">"lock"</span>);<span class="comment">//释放锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">"购买失败，库存不足"</span> + num);</span><br><span class="line">            jedis.del(amountKey + <span class="string">"lock"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"有人正在购买"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样还有一个问题，如果操作很耗时，在lock key过期了之后，操作还没有结束，那么另一个线程又获得了锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">watchLock</span><span class="params">(String amountKey, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String name = Thread.currentThread().getName();</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">    String setnx = jedis.set(amountKey + <span class="string">"lock"</span>, <span class="string">"dasdasdasd"</span>, <span class="string">"nx"</span>, <span class="string">"ex"</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(name + <span class="string">"加锁"</span> + setnx);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"OK"</span>.equals(setnx)) &#123;<span class="comment">//设置成功,代表拿到锁了</span></span><br><span class="line">        jedis.watch(amountKey + <span class="string">"lock"</span>);</span><br><span class="line">        String result = jedis.get(amountKey);</span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(result) &gt;= num) &#123;</span><br><span class="line">            Transaction transaction = jedis.multi();</span><br><span class="line">            transaction.decrBy(amountKey, num);<span class="comment">//剩余数量</span></span><br><span class="line">            System.out.println(name+<span class="string">"购买"</span>+num);</span><br><span class="line">            List&lt;Object&gt; list = transaction.exec();</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;<span class="comment">//事务提交成功</span></span><br><span class="line">                jedis.del(amountKey + <span class="string">"lock"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//事务提交失败</span></span><br><span class="line">                System.out.println(<span class="string">"锁被释放了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            transaction.exec();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jedis.del(amountKey + <span class="string">"lock"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.unwatch();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"有人正在购买"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用LUA脚本保证操作原子性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jedis      Redis客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockKey    锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requestId  请求标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">    String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">    <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">    <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-使用管道"><a href="#12-使用管道" class="headerlink" title="12.使用管道"></a>12.使用管道</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`person`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(</span><br><span class="line">   <span class="string">'*8\r\n'</span>,</span><br><span class="line">   <span class="string">'$'</span>,<span class="keyword">LENGTH</span>(redis_cmd),<span class="string">'\r\n'</span>,redis_cmd,<span class="string">'\r\n'</span>,</span><br><span class="line">   <span class="string">'$'</span>,<span class="keyword">LENGTH</span>(redis_key),<span class="string">'\r\n'</span>,redis_key,<span class="string">'\r\n'</span>,</span><br><span class="line">   <span class="string">'$'</span>,<span class="keyword">LENGTH</span>(hkey1),<span class="string">'\r\n'</span>,hkey1,<span class="string">'\r\n'</span>,<span class="string">'$'</span>,<span class="keyword">LENGTH</span>(hval1),<span class="string">'\r\n'</span>,hval1,<span class="string">'\r\n'</span>,</span><br><span class="line">   <span class="string">'$'</span>,<span class="keyword">LENGTH</span>(hkey2),<span class="string">'\r\n'</span>,hkey2,<span class="string">'\r\n'</span>,<span class="string">'$'</span>,<span class="keyword">LENGTH</span>(hval2),<span class="string">'\r\n'</span>,hval2,<span class="string">'\r\n'</span>,</span><br><span class="line">   <span class="string">'$'</span>,<span class="keyword">LENGTH</span>(hkey3),<span class="string">'\r\n'</span>,hkey3,<span class="string">'\r\n'</span>,<span class="string">'$'</span>,<span class="keyword">LENGTH</span>(hval3),<span class="string">'\r\n'</span>,hval3,<span class="string">'\r\n'</span></span><br><span class="line">)<span class="keyword">FROM</span>(</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="string">'HMSET'</span> <span class="keyword">AS</span> redis_cmd,</span><br><span class="line">   <span class="keyword">concat_ws</span>(<span class="string">':'</span>,<span class="string">'person'</span>, <span class="keyword">id</span>) <span class="keyword">AS</span> redis_key,</span><br><span class="line">   <span class="string">'id'</span> <span class="keyword">AS</span> hkey1, <span class="keyword">id</span> <span class="keyword">AS</span> hval1,</span><br><span class="line">   <span class="string">'name'</span> <span class="keyword">AS</span> hkey2, <span class="keyword">name</span> <span class="keyword">AS</span> hval2,</span><br><span class="line">   <span class="string">'age'</span> <span class="keyword">AS</span> hkey3, age <span class="keyword">AS</span> hval3</span><br><span class="line">   <span class="keyword">From</span> person</span><br><span class="line">)<span class="keyword">AS</span> t</span><br></pre></td></tr></table></figure><p>把脚本存成person.sql文件</p><p>在redis中输入如下命令：</p><p>mysql -u用户名 -p -D数据库名 –default-character-set=utf8 –skip-column-names –raw &lt; person.sql | ./redis-cli –pipe</p><p>–raw: 使mysql不转换字段值中的换行符。<br>–skip-column-names: 使mysql输出的每行中不包含列名。<br>–pipe 将命令封装成redis通信协议定义的数据格式，批量发送给redis执行</p><h2 id="13-位图"><a href="#13-位图" class="headerlink" title="13. 位图"></a>13. 位图</h2><p>​        Bitmaps并不是实际的数据类型，而是定义在String类型上的一个面向字节操作的集合。因为字符串是二进制安全的块，他们的最大长度是512M，最适合设置成2^32个不同字节。</p><p>​        Bitmaps 的最大优势之一在存储信息时极其节约空间。</p><p>​        在我们平时开发过程中，会有一些 bool 型数据需要存取，比如用户一年的签到记录，签了是 1，没签是 0，要记录 365 天。如果使用普通的 key/value，每个用户要记录 365 个，当用户上亿的时候，需要的存储空间是惊人的。 为了解决这个问题，Redis<br>提供了位图数据结构，这样每天的签到记录只占据一个位 ，365 天就是 365 个位，46 个字节 (一个稍长一点的字符串)<br>就可以完全容纳下，这就大大节约了存储空间。 </p><p>​        位图一般可以用在如下场景：</p><p>​        1)用户签到</p><p>​        2)用户在线状态</p><p>​        3)活跃用户统计</p><p>​        4)各种状态值</p><p>​        学习位图，需要了解一下二进制的知识，但不需要太深入。为了方便测试，可以写一个将字符串转换成二进制字节的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"big"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            System.out.println(Integer.toBinaryString(c));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意输出结果是7位，最高位补0凑8位，方便后序计算</p><p>b    01100010</p><p>i     01101001</p><p>g    01100111</p><p>如果按位进行计算，比如把b的最后一位变成1</p><p>01100010-&gt;01100011   就是二进制的+1，在计算机里ascii码，b+1之后就是c</p><p>命令：</p><h4 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h4><p>getbit  key offset     </p><p> 获取key对应的value 第offset比特位 的值（索引从0开始）</p><p>比如</p><p>set hello big</p><p>big对应的二进制是 01100010 01101001 01100111</p><p><img src="../assets/img/1572404751519.png" alt="1572404751519"></p><h4 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h4><p>setbit key offset value</p><p>给key对应值的第offset位设置值(返回原来值)</p><p><img src="../assets/img/1572406382768.png" alt="1572406382768"></p><p>big对应的二进制是 0110001<font color="red">0</font> 01101001 01100111</p><p>第7位是0(索引从0开始)，改成1之后，数据ascii码+1，变成c。</p><h4 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h4><p>bitcount key [start end]</p><p>获取指定范围内(字节)，值为1的个数，注意start和end是字节,1字节是8位，-1表示最后一个字节，-2是倒数第二个字节</p><p><img src="../assets/img/1572406980639.png" alt="1572406980639"></p><p>big对应的二进制是 01100010 01101001 01100111</p><p>bitcount hello 是统计上面所有的1</p><p>bitcount hello 0 0 是统计第0个字节的1(1字节是8位)</p><p>bitcount hello 0 1 统计0-1个字节内的1</p><h4 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h4><p>​    bitop and|or|not|xor destkey key1 [key2…]</p><p>做多个bitmap的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存到destkey中。</p><p><img src="../assets/img/1572407674525.png" alt="1572407674525"></p><h4 id="bitpos-key-bit-start-end"><a href="#bitpos-key-bit-start-end" class="headerlink" title="bitpos key bit [start] [end]"></a>bitpos key bit [start] [end]</h4><p>返回key值中，第一个bit所在的位置</p><p><img src="../assets/img/1572415961468.png" alt="1572415961468"></p><p>字符1 ascii码对应的2进制是00110001</p><p>bitpos num 0 0 是返回第0字节中第一个0的索引</p><p>bitpos num 1 0 是返回第0字节中第一个1的索引</p><h4 id="bitfield"><a href="#bitfield" class="headerlink" title="bitfield"></a>bitfield</h4><p>bitfield将redis字符串看成二进制数组，它配合一些子命令使用</p><p>命令：get type offset 返回指定范围内的  type 是u8表示8位无符号整数，i8是8位有符号整数</p><p>如key对应的value如下(转化为二进制)</p><p>00000000 00000000 00000000 00101100</p><p>bitfield key get u30 0  就是从索引0开始向后获取30位</p><p>00000000 00000000 00000000 001011</p><p>无符号 1011  就是 11</p><p>bitfield key get u30 1 从索引1开始向后获取30位</p><p>00000000 00000000 00000000 0010110 </p><p>无符号10110 是22</p><p>bitfield key get u29 1 从索引1开始向后获取29位</p><p>00000000 00000000 00000000 001011  是11</p><p>命令：set type offset value   对指定的二进制位范围进行设置，并返回它的旧值。</p><p>比如bitfield key set u31 0 23 就是从索引0开始，向后31位，设置值为23</p><p>先找到31位</p><p><font color="red">00000000 00000000 00000000 0000000</font>0 </p><p>23转成二进制是10111，末位对齐赋值</p><p>00000000 00000000 00000000 00<font color="red">10111</font>0 </p><p>命令incrby type ofset increment  对指定的二进制位范围执行加法操作，并返回它的新值。用户可以通过向 <code>increment</code> 参数传入负值来实现相应的减法操作。</p><p>应用场景，记录一个用户一年中登陆状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//日期的初始值</span></span><br><span class="line">   <span class="comment">//下文需要使用日期的偏移量作为redis位图的offset，</span></span><br><span class="line">   <span class="comment">//因此需要将要保存登录状态的日期减去该初始日期。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDate beginDate = LocalDate.of(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       jedis.connect();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLoginStatus</span><span class="params">(String userId, LocalDate date, <span class="keyword">boolean</span> isLogin)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> offset = getDateDuration(beginDate, date);</span><br><span class="line">       System.out.println(<span class="string">"偏移量："</span> + offset);</span><br><span class="line">       jedis.setbit(userId, offset, isLogin);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLoginStatus</span><span class="params">(String userId, LocalDate date)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> offset = getDateDuration(beginDate, date);</span><br><span class="line">       <span class="keyword">return</span> jedis.getbit(userId, offset);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//计算两个日期中间的差值</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getDateDuration</span><span class="params">(LocalDate start, LocalDate end)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> start.until(end, ChronoUnit.DAYS);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String userId = <span class="string">"user_1"</span>;</span><br><span class="line">       LocalDate today = LocalDate.now();</span><br><span class="line">       setLoginStatus(userId, today, <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">boolean</span> todayLoginStatus = getLoginStatus(userId, today);</span><br><span class="line">       System.out.println(String.format(<span class="string">"The loginStatus of %s in %s is %s"</span>, userId, today, todayLoginStatus));</span><br><span class="line">       LocalDate yesterday = LocalDate.now().minusDays(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">boolean</span> yesterdayLoginStatus = getLoginStatus(userId, yesterday);</span><br><span class="line">       System.out.println(String.format(<span class="string">"The loginStatus of %s in %s is %s"</span>, userId, yesterday, yesterdayLoginStatus));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSignDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String host = <span class="string">"192.168.3.74"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户签到</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid  用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 之前的签到状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSign</span><span class="params">(<span class="keyword">int</span> uid, LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = date.getDayOfMonth() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jedis.setbit(buildSignKey(uid, date), offset, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查用户是否签到</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid  用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前的签到状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSign</span><span class="params">(<span class="keyword">int</span> uid, LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = date.getDayOfMonth() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jedis.getbit(buildSignKey(uid, date), offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户签到次数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid  用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前的签到次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSignCount</span><span class="params">(<span class="keyword">int</span> uid, LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedis.bitcount(buildSignKey(uid, date));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当月连续签到次数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid  用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当月连续签到次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getContinuousSignCount</span><span class="params">(<span class="keyword">int</span> uid, LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> signCount = <span class="number">0</span>;</span><br><span class="line">        String type = String.format(<span class="string">"u%d"</span>, date.getDayOfMonth());</span><br><span class="line">        System.out.println(type);</span><br><span class="line">        List&lt;Long&gt; list = jedis.bitfield(buildSignKey(uid, date), <span class="string">"GET"</span>, type, <span class="string">"0"</span>);</span><br><span class="line">        <span class="comment">//其实里面是一个整数，就是把二进制换算成10进制之后的整数</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 取低位连续不为0的个数即为连续签到次数，需考虑当天尚未签到的情况</span></span><br><span class="line">            <span class="keyword">long</span> v = list.get(<span class="number">0</span>) == <span class="keyword">null</span> ? <span class="number">0</span> : list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; date.getDayOfMonth(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v &gt;&gt; <span class="number">1</span> &lt;&lt; <span class="number">1</span> == v) &#123;</span><br><span class="line">                    <span class="comment">// 低位为0且非当天说明连续签到中断了</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    signCount += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                v &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> signCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当月首次签到日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid  用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 首次签到日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getFirstSignDate</span><span class="params">(<span class="keyword">int</span> uid, LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> pos = jedis.bitpos(buildSignKey(uid, date), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> pos &lt; <span class="number">0</span> ? <span class="keyword">null</span> : date.withDayOfMonth((<span class="keyword">int</span>) (pos + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当月签到情况</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid  用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Key为签到日期，Value为签到状态的Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Boolean&gt; <span class="title">getSignInfo</span><span class="params">(<span class="keyword">int</span> uid, LocalDate date)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Boolean&gt; signMap = <span class="keyword">new</span> HashMap&lt;&gt;(date.getDayOfMonth());</span><br><span class="line">        String type = String.format(<span class="string">"u%d"</span>, date.lengthOfMonth());</span><br><span class="line">        List&lt;Long&gt; list = jedis.bitfield(buildSignKey(uid, date), <span class="string">"GET"</span>, type, <span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 由低位到高位，为0表示未签，为1表示已签</span></span><br><span class="line">            <span class="keyword">long</span> v = list.get(<span class="number">0</span>) == <span class="keyword">null</span> ? <span class="number">0</span> : list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = date.lengthOfMonth(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                LocalDate d = date.withDayOfMonth(i);</span><br><span class="line">                signMap.put(formatDate(d, <span class="string">"yyyy-MM-dd"</span>), v &gt;&gt; <span class="number">1</span> &lt;&lt; <span class="number">1</span> != v);</span><br><span class="line">                v &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> signMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> formatDate(date, <span class="string">"yyyyMM"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">formatDate</span><span class="params">(LocalDate date, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">buildSignKey</span><span class="params">(<span class="keyword">int</span> uid, LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"u:sign:%d:%s"</span>, uid, formatDate(date));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserSignDemo demo = <span class="keyword">new</span> UserSignDemo();</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// doSign</span></span><br><span class="line">            <span class="keyword">boolean</span> signed = demo.doSign(<span class="number">1000</span>, today.minusDays(<span class="number">3</span>));</span><br><span class="line">            <span class="keyword">if</span> (signed) &#123;</span><br><span class="line">                System.out.println(<span class="string">"您已签到："</span> + formatDate(today, <span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"签到完成："</span> + formatDate(today, <span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// checkSign</span></span><br><span class="line">            <span class="keyword">boolean</span> signed = demo.checkSign(<span class="number">1000</span>, today);</span><br><span class="line">            <span class="keyword">if</span> (signed) &#123;</span><br><span class="line">                System.out.println(<span class="string">"您已签到："</span> + formatDate(today, <span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"尚未签到："</span> + formatDate(today, <span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// getSignCount</span></span><br><span class="line">            <span class="keyword">long</span> count = demo.getSignCount(<span class="number">1000</span>, today);</span><br><span class="line">            System.out.println(<span class="string">"本月签到次数："</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// getContinuousSignCount</span></span><br><span class="line">            <span class="keyword">long</span> count = demo.getContinuousSignCount(<span class="number">1000</span>, today);</span><br><span class="line">            System.out.println(<span class="string">"连续签到次数："</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// getFirstSignDate</span></span><br><span class="line">            LocalDate date = demo.getFirstSignDate(<span class="number">1000</span>, today);</span><br><span class="line">            System.out.println(<span class="string">"本月首次签到："</span> + formatDate(date, <span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// getSignInfo</span></span><br><span class="line">            System.out.println(<span class="string">"当月签到情况："</span>);</span><br><span class="line">            Map&lt;String, Boolean&gt; signInfo = <span class="keyword">new</span> TreeMap&lt;&gt;(demo.getSignInfo(<span class="number">1000</span>, today));</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Boolean&gt; entry : signInfo.entrySet()) &#123;</span><br><span class="line">                System.out.println(entry.getKey() + <span class="string">": "</span> + (entry.getValue() ? <span class="string">"√"</span> : <span class="string">"-"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-发布订阅"><a href="#3-发布订阅" class="headerlink" title="3. 发布订阅"></a>3. 发布订阅</h2><p>SUBSCRIBE channel [channel …]  订阅一个或者多个频道</p><p><img src="G:/blog/source/assets/img/1556289020256.png" alt="1556289020256"></p><p>PUBLISH channel message   向频道发送一条信息</p><p><img src="G:/blog/source/assets/img/1556289255438.png" alt="1556289255438"></p><p>订阅端收到信息</p><p><img src="G:/blog/source/assets/img/1556289345346.png" alt="1556289345346"></p><h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h2><p>MULTI  开启事务</p><p>EXEC 执行事务</p><p>DISCARD 放弃事务块中所有命令</p><p>WATCH 监视一个key</p><p>UNWATCH 取消对key的监视</p><p><img src="G:/blog/source/assets/img/1556289932613.png" alt="1556289932613"></p><p>如果在事务提交时，watch的key改变，则事务不能提交</p><h2 id="5-主从复制"><a href="#5-主从复制" class="headerlink" title="5.主从复制"></a>5.主从复制</h2><p>做主从复制的时候，主节点不需要做任何变动。从节点需要做如下配置：</p><p>(同一台机器上模拟，记得改端口)</p><p><img src="G:/blog/source/assets/img/1556290721824.png" alt="1556290721824"></p><p>启动从节点</p><p>在bin目录下执行./redis-server redis.conf</p><p>在主节点上添加数据：</p><p><img src="G:/blog/source/assets/img/1556290810486.png" alt="1556290810486"></p><p>去从节点查询数据：</p><p><img src="G:/blog/source/assets/img/1556290832397.png" alt="1556290832397"></p><p>使用info replication查看节点情况。 </p><p><img src="G:/blog/source/assets/img/1556290849609.png" alt="1556290849609"></p><p>从节点是只读节点，不能添加数据。如果主节点挂了，那么就不能再添加数据了。</p><p><img src="G:/blog/source/assets/img/1556290866817.png" alt="1556290866817"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;a href=&quot;https://www.jianshu.com/p/06ab9daf921d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/06ab9daf921d&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;看看这个 &lt;a href=&quot;https://www.jianshu.com/p/06ab9daf921d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/06ab9daf921d&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal-面试必问深度解析</title>
    <link href="http://yoursite.com/2019/11/12/ThreadLocal-%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/11/12/ThreadLocal-面试必问深度解析/</id>
    <published>2019-11-12T01:14:47.000Z</published>
    <updated>2019-11-19T01:29:34.039Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://www.jianshu.com/p/98b68c97df9b" target="_blank" rel="noopener">https://www.jianshu.com/p/98b68c97df9b</a> </p><a id="more"></a><h3 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h3><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p><h3 id="从数据结构入手"><a href="#从数据结构入手" class="headerlink" title="从数据结构入手"></a>从数据结构入手</h3><p><strong>下图为ThreadLocal的内部结构图</strong></p><p><img src="/assets%5Cimg%5C20191112.png" alt="ThreadLocal的内部结构图"></p><p>ThreadLocal结构内部</p><p>从上面的结构图，我们已经窥见ThreadLocal的核心机制：</p><ul><li>每个Thread线程内部都有一个Map。</li><li>Map里面存储线程本地对象（key）和线程的变量副本（value）</li><li>但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</li></ul><p>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p><p>Thread线程内部的Map在类中描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深入解析ThreadLocal"><a href="#深入解析ThreadLocal" class="headerlink" title="深入解析ThreadLocal"></a>深入解析ThreadLocal</h3><p>ThreadLocal类提供如下几个核心方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public T get()</span><br><span class="line">public void set(T value)</span><br><span class="line">public void remove()</span><br></pre></td></tr></table></figure><ul><li>get()方法用于获取当前线程的副本变量值。</li><li>set()方法用于保存当前线程的副本变量值。</li><li>initialValue()为当前线程初始副本变量值。</li><li>remove()方法移除当前前程的副本变量值。</li></ul><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;@link #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span>(<span class="params">Thread t</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    T <span class="keyword">value</span> = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：<br> 1.获取当前线程的ThreadLocalMap对象threadLocals<br> 2.从map中获取线程存储的K-V Entry节点。<br> 3.从Entry节点获取存储的Value副本值返回。<br> 4.map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。</p><h4 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;@link #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">T <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span>(<span class="params">Thread t</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span>(<span class="params">Thread t, T firstValue</span>)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：<br> 1.获取当前线程的成员变量map<br> 2.map非空，则重新将ThreadLocal和新的value副本放入到map中。<br> 3.map空，则对线程的成员变量ThreadLocalMap进行初始化创建，并将ThreadLocal和value副本放入map中。</p><h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the current thread's value for this thread-local</span></span><br><span class="line"><span class="comment"> * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment"> * &#123;@linkplain #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment"> * reinitialized by invoking its &#123;@link #initialValue&#125; method,</span></span><br><span class="line"><span class="comment"> * unless its value is &#123;@linkplain #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment"> * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;initialValue&lt;/tt&gt; method in the current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">void</span> remove() &#123;</span><br><span class="line"> ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"> <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">     m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove方法比较简单，不做赘述。</p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。</p><p><img src="/assets%5Cimg%5C201911122.png" alt="ThreadLocalMap类图"></p><p>ThreadLocalMap类图</p><p>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    <span class="built_in">Object</span> value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, <span class="built_in">Object</span> v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。</p><p>ThreadLocalMap的成员变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">     * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of entries in the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hash冲突怎么解决"><a href="#Hash冲突怎么解决" class="headerlink" title="Hash冲突怎么解决"></a>Hash冲突怎么解决</h4><p>和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</p><p>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increment i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decrement i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然ThreadLocalMap采用线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。</p><p><strong>所以这里引出的良好建议是：每个线程只存一个变量，这样的话所有的线程存放到map中的Key都是相同的ThreadLocal，如果一个线程要保存多个变量，就需要创建多个ThreadLocal，多个ThreadLocal放入Map中时会极大的增加Hash冲突的可能。</strong></p><h4 id="ThreadLocalMap的问题"><a href="#ThreadLocalMap的问题" class="headerlink" title="ThreadLocalMap的问题"></a>ThreadLocalMap的问题</h4><p>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><p><strong>如何避免泄漏</strong><br> 既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。</p><p>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Session&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Session&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.<span class="keyword">set</span>(<span class="keyword">new</span> Session(<span class="number">1</span>, <span class="string">"Misout的博客"</span>));</span><br><span class="line">    <span class="comment">// 其它业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.<span class="keyword">remove</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>还记得Hibernate的session获取场景吗？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal&lt;Session&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Session&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Session</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getCurrentSession</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Session session =  threadLocal.<span class="keyword">get</span>();</span><br><span class="line">    <span class="comment">//判断Session是否为空，如果为空，将创建一个session，并设置到本地线程变量中</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(session ==<span class="literal">null</span>&amp;&amp;!session.isOpen())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sessionFactory==<span class="literal">null</span>)&#123;</span><br><span class="line">                rbuildSessionFactory();<span class="comment">// 创建Hibernate的SessionFactory</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                session = sessionFactory.openSession();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        threadLocal.<span class="keyword">set</span>(session);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么？每个线程访问数据库都应当是一个独立的Session会话，如果多个线程共享同一个Session会话，有可能其他线程关闭连接了，当前线程再执行提交时就会出现会话已关闭的异常，导致系统异常。此方式能避免线程争抢Session，提高并发下的安全性。</p><p>使用ThreadLocal的典型场景正如上面的数据库连接管理，线程会话管理等场景，只适用于独立变量副本的情况，如果变量为全局共享的，则不适用在高并发下使用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。</li><li>ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。</li><li>适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方案。</li></ul><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><a href="https://www.jianshu.com/p/a1cd61fa22da" target="_blank" rel="noopener">ThreadLocal内存泄漏真因探究</a></li><li><a href="https://www.jianshu.com/p/ca6cbc246d20" target="_blank" rel="noopener">Java中的四种引用类型（强、软、弱、虚）</a></li><li><a href="https://www.jianshu.com/p/9d7ebe37215e" target="_blank" rel="noopener">分布式全局唯一ID生成策略</a></li><li><a href="https://www.jianshu.com/p/b7dda385f83d" target="_blank" rel="noopener">ConcurrentHashMap与红黑树实现分析Java8  好文强烈推荐</a></li><li><a href="https://www.jianshu.com/p/967a01538628" target="_blank" rel="noopener">如何快速成长为技术大牛？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自 &lt;a href=&quot;https://www.jianshu.com/p/98b68c97df9b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/98b68c97df9b&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Redis常用命令</title>
    <link href="http://yoursite.com/2019/11/11/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/11/11/Redis常用命令/</id>
    <published>2019-11-11T07:00:22.000Z</published>
    <updated>2019-11-19T01:28:07.466Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a> Redis 命令参考</p><h3 id="2-1-通用命令"><a href="#2-1-通用命令" class="headerlink" title="2.1 通用命令"></a>2.1 通用命令</h3><h4 id="KEYS"><a href="#KEYS" class="headerlink" title="KEYS"></a>KEYS</h4><p>keys *   </p><p>获取当前所有的键</p><h4 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h4><p>exists key [key  key  …]  </p><p>判断某个键是否存在，返回存在的个数，不存在返回0</p><h4 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a>DEL</h4><p>del key  [key  key  …] </p><p>删除键，返回被删除的个数</p><h4 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a>TYPE</h4><p>type key  </p><p>返回一个key对应的数据类型</p><h4 id="EXPIRE"><a href="#EXPIRE" class="headerlink" title="EXPIRE"></a>EXPIRE</h4><p>expire key seconds</p><p>为给定 key设置生存时间，当 key过期时(生存时间为 0 )，它会被自动删除,单位是秒。</p><p>类似的命令有PEXPIRE，设置单位是毫秒</p><h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>ttl key</p><p>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</p><p>当 key 不存在时，返回 -2 。</p><p>当 key存在但没有设置剩余生存时间时，返回 -1 。</p><p>否则，以秒为单位，返回 key的剩余生存时间。</p><p>类似命令有PTTL，单位是毫秒</p><h4 id="RENAME"><a href="#RENAME" class="headerlink" title="RENAME"></a>RENAME</h4><p>rename key new key</p><p>将 key改名为 newkey 。</p><p>当 key和 newkey 相同，或者 key 不存在时，返回一个错误。</p><p>当 newkey已经存在时， RENAME 命令将覆盖旧值。</p><h4 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h4><p>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]<br>返回或保存给定列表、集合、有序集合 key 中经过排序的元素。<br>排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</p><h4 id="FLUSHDB-慎用"><a href="#FLUSHDB-慎用" class="headerlink" title="FLUSHDB(慎用)"></a>FLUSHDB(慎用)</h4><p>清空redis所有数据</p><h3 id="2-2-String（字符串）"><a href="#2-2-String（字符串）" class="headerlink" title="2.2 String（字符串）"></a>2.2 String（字符串）</h3><p>Redis字符串是以key-value键值形式存储数据的。操作字符串使用set和get命令</p><h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><p>添加值使用set命令</p><p>set key value</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>查询值使用get命令</p><p>get key</p><p>如图：</p><p><img src="/assets/img/1556256749737.png" alt="1556256749737"></p><p>redis中没有修改，给已经存在的key存入新的值，就会覆盖掉原来的值：</p><p><img src="/assetsimg/1556256771880.png" alt="1556256771880"></p><p>一个键最多能存512M的数据</p><h4 id="INCR-和-INCRBY"><a href="#INCR-和-INCRBY" class="headerlink" title="INCR 和 INCRBY"></a>INCR 和 INCRBY</h4><p>incr key  实现整数值加1。如果value不是数字类型，则报错</p><p>incrby key increment  整数值增加increment</p><h4 id="DECR-和-DECRBY"><a href="#DECR-和-DECRBY" class="headerlink" title="DECR 和 DECRBY"></a>DECR 和 DECRBY</h4><p>decr key  实现整数值减1</p><p>decrby key increment   整数值增减increment</p><h4 id="INCRBYFLOAT"><a href="#INCRBYFLOAT" class="headerlink" title="INCRBYFLOAT"></a>INCRBYFLOAT</h4><p>incrbyfloat key increment  数值增加一个浮点数</p><h4 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a>APPEND</h4><p>append key value 在字符串后追加value</p><h4 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a>STRLEN</h4><p>strlen key 返回value的长度，不存在返回0</p><h4 id="MGET-和-MSET"><a href="#MGET-和-MSET" class="headerlink" title="MGET 和 MSET"></a>MGET 和 MSET</h4><p>mget key [key key ]  同时查询多个key(用空格分割)</p><p>mset key value [key value …]同时设置多个key-value</p><h4 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h4><p>setnx key value</p><p>用法同set</p><p>将 key 的值设为 value ，当且仅当 key 不存在，若给定的 key 已经存在，则 SETNX 不做任何动作。</p><p>成功返回1，否则返回0</p><h4 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a>SETEX</h4><p>setex key seconds value</p><p>设置key的值为value,并将 key 的生存时间设为 seconds (以秒为单位)。</p><p>如果 key 已经存在， SETEX 命令将覆写旧值。</p><h4 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a><strong>GETRANGE</strong></h4><p>getrange key start end<br>返回 key中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start和 end 在内)。<br>负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。</p><h3 id="2-3-Hash（哈希表）"><a href="#2-3-Hash（哈希表）" class="headerlink" title="2.3 Hash（哈希表）"></a>2.3 Hash（哈希表）</h3><p>hash是以key-field-value的形式存储数据的。一个key下面有多个field，每个field有一个对应的值</p><h4 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h4><p>hset key field value 设置key中某字段值</p><h4 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h4><p>hget key field  查询key中某字段值</p><h4 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h4><p>hdel key field  删除key中某个字段</p><p><img src="/assetsimg/1556257701992.png" alt="1556257701992"></p><h4 id="HMSET"><a href="#HMSET" class="headerlink" title="HMSET"></a>HMSET</h4><p>hmset key field value [field value …] 一次设置key的多个field值</p><h4 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h4><p>hmget key field [field …] 查询key的多个field</p><h4 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h4><p>hgetall key 返回key中所有字段和字段值</p><h4 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h4><p>hexists key field 判断是否存在，存在返回1，否则是0</p><h4 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h4><p>hsetnx key field value 和hset类似，不同的是要求这个key-field不存在</p><h4 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a>HINCRBY</h4><p>hincrby key field increment  同incrby,给field自增，自减increment是负数</p><h4 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a>HKEYS</h4><p>hkeys key 返回key下所有的field</p><h4 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h4><p>hvals key 返回key下所有的字段值</p><h4 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h4><p>hlen key 返回key中总字段数</p><h4 id="HINCRBYFLOAT"><a href="#HINCRBYFLOAT" class="headerlink" title="HINCRBYFLOAT"></a>HINCRBYFLOAT</h4><p>用法同HINCRBY，为哈希表 key 中的域 field 加上浮点数增量 increment 。</p><p>如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。</p><p>如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。</p><h3 id="2-4-Set（集合）"><a href="#2-4-Set（集合）" class="headerlink" title="2.4 Set（集合）"></a>2.4 Set（集合）</h3><p>set是无序集合，集合中元素值唯一（不允许有重复元素）。</p><p><img src="/assetsimg/1556257733103.png" alt="1556257733103"></p><h4 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h4><p>sadd key member [member …] 向集合中添加元素</p><h4 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h4><p>srem key member [member …] 删除集合中元素</p><h4 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h4><p>smembers key 返回集合中所有元素</p><h4 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h4><p>sismember key member 判断是否存在，存在返回1，否则是0</p><h4 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h4><p>scard key 返回集合中元素个数</p><h4 id="SDIFF-SINTER-SUNION"><a href="#SDIFF-SINTER-SUNION" class="headerlink" title="SDIFF/SINTER/SUNION"></a>SDIFF/SINTER/SUNION</h4><p>sdiff key [key]  返回A集合中有，B集合中没有的数据，即A-B</p><p>sinter key [key] 返回A和B中都由的数据，交集</p><p>sunion key [key] 返回A和B中所有元素，重复元素只出现一次，并集</p><h4 id="SDIFFSTORE-SINTERSTORE-SUNIONSTORE"><a href="#SDIFFSTORE-SINTERSTORE-SUNIONSTORE" class="headerlink" title="SDIFFSTORE/SINTERSTORE/SUNIONSTORE"></a>SDIFFSTORE/SINTERSTORE/SUNIONSTORE</h4><p>sdiffstore destination key [key …] ，差运算并存储到destination新集合中</p><p>sinterstore destination key [key …]，交运算并存储到destination新集合中</p><p>sunionstore destination key [key …]，并运算并存储到destination新集合中</p><h4 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h4><p>srandmember key [count] 随机输出count个元素，默认是1个，count小于0可能出现重复元素，count大于0是不重复的</p><h4 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h4><p>spop key [count] 随机弹出count个元素，弹出的元素将不在集合中</p><h3 id="2-5-List-列表"><a href="#2-5-List-列表" class="headerlink" title="2.5 List (列表)"></a>2.5 List (列表)</h3><p>列表是一个线性集合</p><h4 id="LPUSH-RPUSH-LPUSHX"><a href="#LPUSH-RPUSH-LPUSHX" class="headerlink" title="LPUSH/RPUSH/LPUSHX"></a>LPUSH/RPUSH/LPUSHX</h4><p>使用lpush或者rpush添加数据，lpush是从列表头插入，使用rpush是从结尾插入。</p><p><img src="/assetsimg/1556257653236.png" alt="1556257653236"></p><p>LPUSHX key value</p><p>将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。</p><h4 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h4><p>lrange用于遍历列表，lrange key 0 -1是返回整个列表</p><p><img src="/assetsimg/1556257670997.png" alt="1556257670997"></p><p>一个列表最多可以存2^32-1个数据</p><h4 id="LPOP-RPOP"><a href="#LPOP-RPOP" class="headerlink" title="LPOP/RPOP"></a>LPOP/RPOP</h4><p>lpop key 移除左边第一个元素</p><p>rpop key 移除右边第一个元素</p><h4 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h4><p>llen key 返回列表中元素个数</p><h4 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h4><p>lindex key index 返回第index个位置的数字，-1表示最右边，0是最左边</p><h4 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h4><p>lset key index value 把列表的第index个元素设置成value</p><h4 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h4><p>ltrim key start stop 保留列表中的片段(多余的就删了)</p><h4 id="RPOPLPUSH"><a href="#RPOPLPUSH" class="headerlink" title="RPOPLPUSH"></a>RPOPLPUSH</h4><p>rpoplpush source target 从source移动到target，一次操作一个元素</p><h3 id="2-6-Zset-Sorted-Set-有序集合"><a href="#2-6-Zset-Sorted-Set-有序集合" class="headerlink" title="2.6 Zset (Sorted Set 有序集合)"></a>2.6 Zset (Sorted Set 有序集合)</h3><p>zset是有序集合：</p><h4 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h4><p>zadd key score member  用于添加元素，member按score排序，score相同，按member排序</p><p><img src="/assetsimg/1556257764812.png" alt="1556257764812"></p><h4 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h4><p>zscore key member 返回member的score</p><h4 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h4><p>zrange key start end [withscores] </p><p>返回成员，score升序排列，加withscores会返回score</p><p><img src="/assetsimg/1556257786012.png" alt="1556257786012"></p><h4 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a>ZREVRANGE</h4><p>zrevrange start end [withscores] 同zrange，score降序排列</p><h4 id="ZRANGEEBYSCORE"><a href="#ZRANGEEBYSCORE" class="headerlink" title="ZRANGEEBYSCORE"></a>ZRANGEEBYSCORE</h4><p>zrangebyscore key min max [withscores] [limit offest count] 按score范围返回元素，从左偏移offset个元素，返回前count个</p><h4 id="ZINCRYBY"><a href="#ZINCRYBY" class="headerlink" title="ZINCRYBY"></a>ZINCRYBY</h4><p>zincrby key incremtment member 增加元素score</p><h4 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h4><p>zcount key min max 计算score在min到max之间的元素个数</p><h4 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h4><p>zrank key member 返回集合中member的索引，score升序</p><h4 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a>ZREVRANK</h4><p>zrevrank key member 返回集合中member的索引，score降序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;a href=&quot;http://doc.redisfans.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://doc.redisfans.com/&lt;/a&gt; Redis 命令参考&lt;/p&gt;
&lt;h3 id=&quot;2-1-通用命令&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="http://yoursite.com/2019/11/11/Redis%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/11/11/Redis入门/</id>
    <published>2019-11-11T00:34:17.000Z</published>
    <updated>2019-11-19T01:26:22.066Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://cloud.tencent.com/developer/doc/1203" target="_blank" rel="noopener">https://cloud.tencent.com/developer/doc/1203</a> </p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>由意大利人开发的一款内存高速缓存数据库.是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。<br>支持丰富的数据类型:String,list,set,zset(sorted set),hash等</p><a id="more"></a><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>Redis以内存作为数据存储介质,所以读写数据的效率极高,远远超过数据库.</li><li>以设置和读取一个256字节字符串为例,它的读取速度可高达110000次/s,写速度高达81000次/秒.</li><li>Redis和Memcache不同的是,存储在Redis中的数据是持久化的,断电或重启后,数据也不会丢失.</li><li>Redistribution的存储分为内存存储,磁盘存储和log文件三部分.<br>  重启后,Redis可以从磁盘 重新将数据加载到内存中,这些可以通过配置文件配置.</li><li>Redis支持主从模式,可以配置集群,这样更利于支撑起大型的项目,这也是Redis的一大亮点.</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>众多语言都支持Redis,因为Redis交换数据快,所以在服务器中常用来存储一些需要频繁调取的数据,这样可以大大节省系统直接读取磁盘来获得数据的I/O开销,更重要的是可以极大提升速度.</li><li>例如一个大型网站每天有100万人访问,其中一个新闻板块,如果直接从数据库查询,那么一天就要多消耗100万次数据请求.这个就可以用Redis完成,将这种数据存到Redis(内存)中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> $ find . -type f -executable</span><br><span class="line">./redis-benchmark //用于进行redis性能测试的工具</span><br><span class="line">./redis-check-dump //用于修复出问题的dump.rdb文件</span><br><span class="line">./redis-cli //redis的客户端</span><br><span class="line">./redis-server //redis的服务端</span><br><span class="line">./redis-check-aof //用于修复出问题的AOF文件</span><br><span class="line">./redis-sentinel //用于集群管理</span><br></pre></td></tr></table></figure></li></ul><h3 id="windows下使用Redis"><a href="#windows下使用Redis" class="headerlink" title="windows下使用Redis"></a>windows下使用Redis</h3><p>1.下载.Redis解压后免安装，注意解压路径不要有中文<br>2.双击运行redis-server.exe，或者在cmd命令下运行redis<br><code>./redis-server.exe redis.windows.conf</code><br>\assets/img/image-20191111104719331.png)</p><p>如果启动后报如下异常，需要修改maxheap。</p><p><img src="/assets/img/2019111101.png" alt="1556201669659"></p><p>如果看到上面的异常，打开redis.windows.conf，找到maxheap，将数字调大：</p><p><img src="/assets/img/2019111102.png" alt="1556201756309"></p><p>3.下载并安装Redis Desktop Manager(图形界面管理,也可以使用自带命令窗口,见下集群),连接Redis<br><img src="/assets/img/image-20191111104928641.png" alt="image-20191111104928641" style="zoom:50%;"><br><img src="/assets/img/image-20191111105011471.png" alt="image-20191111105011471" style="zoom:50%;"></p><p>4.添加数据<br><img src="/assets/img/image-20191111105715961.png" alt="image-20191111105715961" style="zoom:50%;"></p><p>右键add new key–&gt;    <img src="/assets/img/image-20191111105624517.png" alt="image-20191111105624517" style="zoom:50%;"></p><h2 id="linux安装"><a href="#linux安装" class="headerlink" title="linux安装"></a>linux安装</h2><p>安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：</p><p>​        <code>yum install make cmake gcc gcc-c++</code></p><p>把源码包上传到/usr/local/software/下，在此目录下，解压安装包：</p><p>​        <code>tar-zxvf 安装包名</code>     </p><p>如果Redis 执行 make #error “Newer version of jemalloc required”解决办法是执行：</p><p>​        <code>make MALLOC=libc</code></p><p>安装，PREFIX参数指定redis的安装目录，命令如下：</p><p>​        <code>make install PREFIX=/usr/local/software/redis</code></p><p>进入安装后的路径，就是cd /usr/local/software/redis</p><p>在bin目录下执行</p><p><img src="/assets/img/1556256749737.png" alt="1556256749737"></p><p><img src="/assets/img/2019111103.png" alt="1556202496253"></p><p>这种方式是前端启动，缺点是ssh命令窗口关了之后服务就会停止</p><p> 后台启动：</p><p>把redis源码包解压目录下的redis.conf复制到安装目录的bin下</p><p>cp /usr/local/software/redis-3.2.11/redis.conf /usr/local/software/redis/bin</p><p>修改配置文件（bin下面的redis.conf）：</p><p>redis默认只能本机访问，要把下面两句改一下才能远程访问。</p><p><img src="/assets/img/2019111105.png" alt="1556202585096"></p><p>设置后台启动 </p><p><img src="/assets/img/2019111106.png" alt="1556202601977"></p><p>在bin目录下执行./redis-server redis.conf</p><p>测试连接</p><p><code>./redis-cli</code></p><p><img src="/assets/img/2019111107.png" alt="1556202632575"></p><p>停止redis</p><p><code>./bin/redis-cli shutdown</code></p><p>redis-cli默认连接的是本机的6379端口，如果连其他机器和端口，使用如下命令：</p><p><code>./bin/redis-cli -h 主机地址 -p 端口</code></p><h3 id="Redis集群-主从模式"><a href="#Redis集群-主从模式" class="headerlink" title="Redis集群-主从模式"></a>Redis集群-主从模式</h3><p>复制三份作为伪集群<br><img src="/assets/img/image-20191111110056715.png" alt="image-20191111110056715"></p><p>redis.windows.conf修改配置信息</p><p>ip地址(不需要修改):<br><img src="/assets/img/image-20191111110220526.png" alt="image-20191111110220526"></p><p>端口号(改成三个不同端口号):<br><img src="/assets/img/image-20191111110311025.png" alt="image-20191111110311025"></p><p> 指定本地数据库文件名<br><img src="/assets/img/image-20191111110549033.png" alt="image-20191111110549033"></p><p>主从配置:设置主服务的ip:127.0.0.1,port:6381<br><img src="/assets/img/image-20191111111058246.png" alt="image-20191111111058246"></p><p>启动服务.(双击启动默认6739,可以修改系统环境变量)</p><p>使用自带命令窗口:</p><p>切换到redis目录下运行 <code>redis-cli.exe -h 127.0.0.1 -p 6379</code> 。<br><img src="/assets/img/image-20191111113733236.png" alt="image-20191111113733236"></p><p>设置键值对 set key value<br>取出键值对 get key<br><img src="/assets/img/image-20191111114006771.png" alt="image-20191111114006771"></p><p>主从集群:只能通过主服务器写入数据,从服务器只能读取数据.当主服务挂掉后,集群中将无法写入数据.</p><p>从服务只能读不能写:<br><img src="/assets/img/image-20191111114219193.png" alt="image-20191111114219193"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;a href=&quot;https://cloud.tencent.com/developer/doc/1203&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cloud.tencent.com/developer/doc/1203&lt;/a&gt; &lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;由意大利人开发的一款内存高速缓存数据库.是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。&lt;br&gt;支持丰富的数据类型:String,list,set,zset(sorted set),hash等&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>emacs安装</title>
    <link href="http://yoursite.com/2019/11/08/emacs%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/11/08/emacs安装/</id>
    <published>2019-11-08T07:21:15.000Z</published>
    <updated>2019-11-11T05:29:50.697Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://www.cnblogs.com/felixwang2/p/10281092.html" target="_blank" rel="noopener">https://www.cnblogs.com/felixwang2/p/10281092.html</a> </p><p> <a href="https://ruby-china.org/topics/37062" target="_blank" rel="noopener">https://ruby-china.org/topics/37062</a> </p><p>看这两个</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;a href=&quot;https://www.cnblogs.com/felixwang2/p/10281092.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/felixwang2/p/10281092.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://ruby-china.org/topics/37062&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ruby-china.org/topics/37062&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;看这两个&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>[error]startup.sh启动闪退</title>
    <link href="http://yoursite.com/2019/11/08/%5Berror%5Dstartup.sh%E5%90%AF%E5%8A%A8%E9%97%AA%E9%80%80/"/>
    <id>http://yoursite.com/2019/11/08/[error]startup.sh启动闪退/</id>
    <published>2019-11-08T03:39:43.000Z</published>
    <updated>2019-11-19T01:05:24.148Z</updated>
    
    <content type="html"><![CDATA[<p>一、首先查看端口是否被占用了，一般Tomcat的默认端口是8080，可以在管理员命令行通过“netstat -ano|findstr “8080””的命令查看当前是否有进程占用了端口。</p><a id="more"></a><p>1.如果端口占用了：</p><p><img src="/assets/img/20181021001416935.jfif" alt="img"></p><p>则根据PID（进程id号）来查这个占用端口的是哪个程序，命令是“tasklist|findstr “27900””（注意PID是最后一列的数，输入命令行的时候记得该空格的地方要空格，如下图）：</p><p> <img src="/assets/img/20181021002138841.jfif" alt="img"> </p><p>如上图通过PID找到占用8080端口的程序是java.exe，下面在通过命令行“taskkill /f /t /im java.exe”结束该进程（注意“/”之前都有空格）：</p><p><img src="/assets/img/20181021002654300.jfif" alt="img">  </p><p>至此，java.exe这个进程就被结束了。</p><p>2.如果端口没被占用，则可能是第二个点引发的问题</p><p>二、这个情况发生的前提是使用的Tomcat是免安装版本的。因为在启动tomcat是需要读取环境变量和配置信息，缺少了这些信息，就不能登记环境变量，导致了tomcat的闪退。<br>解决办法：<br>1：在已解压的tomcat的bin文件夹下找到startup.bat，右击-&gt;编辑。在文件头加入下面两行：<br>SET JAVA_HOME=D:\Java\jdk1.7 （java jdk目录）<br>SET TOMCAT_HOME=E:\tomcat-7.0 （解压后的tomcat文件目录）</p><p>2.在已解压的tomcat的bin文件夹下找到shutdown.bat，右击-&gt;编辑。在文件头加入下面两行：<br>SET JAVA_HOME=D:\Java\jdk1.7 （java jdk目录）<br>SET TOMCAT_HOME=E:\tomcat-7.0 （解压后的tomcat文件目录）</p><p>三、server.xml配置文件出错<br>这是新手最容易犯的错误，也是最不容易被发现的，以下内容敲黑板画重点！</p><p>在Tomcat安装的主目录中，进入“conf”配置目录下，找到server.xml这个文件，用记事本打开。</p><p> <img src="/assets/img/20181021004440704.jfif" alt="img"> </p><p> <img src="/assets/img/20181021004518882.jfif" alt="img"> </p><p> <img src="/assets/img/20181021005058356.png" alt="img"> </p><p>找到配置web路径的地方，将其改为自己项目中web的实际路径。</p><p>配置完之后保存，再重启Tomcat就可以了<br>————————————————<br>版权声明：本文为CSDN博主「SCAU林庭辉」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/scau_lth/article/details/83218335" target="_blank" rel="noopener">https://blog.csdn.net/scau_lth/article/details/83218335</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、首先查看端口是否被占用了，一般Tomcat的默认端口是8080，可以在管理员命令行通过“netstat -ano|findstr “8080””的命令查看当前是否有进程占用了端口。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nginx入门</title>
    <link href="http://yoursite.com/2019/11/08/nginx%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/11/08/nginx入门/</id>
    <published>2019-11-08T02:18:15.000Z</published>
    <updated>2019-11-19T01:05:07.944Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Nginx中文文档：<a href="http://www.nginx.cn/doc/" target="_blank" rel="noopener">http://www.nginx.cn/doc/</a></p></blockquote><h3 id="单应用项目开发"><a href="#单应用项目开发" class="headerlink" title="单应用项目开发"></a>单应用项目开发</h3><p>特点：<br>1.所有功能都集中在一个项目里<br>    1）职能功能：登录，注册，购买，搜索…<br>    2）代码角度：dao,service,controller,view<br>2.部署运行在一个服务器上<br>弊端:<br>tomcat200个并发请求处理，高并发请求无法满足。</p><p>解决办法：集群 分布式</p><a id="more"></a><p>集群</p><p>什么是集群？就是同样的事情多个人做。或者说同一个程序部署到堕胎服务器上。</p><p>集群实质:去中心化</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>一个事情分开做，一个程序也可以拆分，就是分布式。<br>横向拆：按职能功能    登录，注册，搜索，购买<br>纵向拆：按代码：    dao，service，controller，view(前后端分离)</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>实现分布式的技术</p><ul><li>微:一个程序只有一个功能</li></ul><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>解压多个tomcat,修改端口号<br>分别启动tomcat<br>修改nginx下的conf文件夹里的nginx.conf配置文件,对nginx服务进行配置<br>    nginx-1.10.3\conf\nginx.conf<br><img src="/assets/img/image-20191108141953850.png" alt="image-20191108141953850"></p><p><img src="/assets/img/image-20191108142042664.png" alt="image-20191108142042664"></p><p>修改tomcat的欢迎页以便观察.</p><p>访问nginx的端口</p><h3 id="集群的好处"><a href="#集群的好处" class="headerlink" title="集群的好处"></a>集群的好处</h3><p>处理高并发<br>宕机后,不影响整个的运行</p><h3 id="Nginx工作原理"><a href="#Nginx工作原理" class="headerlink" title="Nginx工作原理"></a>Nginx工作原理</h3><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>正向代理:代理距离客户端近<br>反向代理:在服务端<br>其中,Nginx是反向代理</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>将服务器接收到的请求按照规则分发的过程,称为负载均衡.<br>nginx支持的负载均衡调度算法:<br>1.weight轮询(默认):<br>2.ip_hash:每个请求按照发起客户端的ip的hash结果进行匹配,这样的算法下一个固定ip地址的客户总会访问到同一个后端服务器,这也在一定程度上解决了集群部署环境下session共享的问题(但是不能用这个方法来解决session共享的问题)<br>即:根据ip地址的Hash值来分配处理的服务器<br>3.fair:智能调整调度算法,动态的根据后端服务器的请求处理到相应的时间进行分配<br>看起来很不错,然鹅默认不支持,如果使用需要安装模块<br>4.url_hash默认不支持</p><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Nginx中文文档：&lt;a href=&quot;http://www.nginx.cn/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.nginx.cn/doc/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单应用项目开发&quot;&gt;&lt;a href=&quot;#单应用项目开发&quot; class=&quot;headerlink&quot; title=&quot;单应用项目开发&quot;&gt;&lt;/a&gt;单应用项目开发&lt;/h3&gt;&lt;p&gt;特点：&lt;br&gt;1.所有功能都集中在一个项目里&lt;br&gt;    1）职能功能：登录，注册，购买，搜索…&lt;br&gt;    2）代码角度：dao,service,controller,view&lt;br&gt;2.部署运行在一个服务器上&lt;br&gt;弊端:&lt;br&gt;tomcat200个并发请求处理，高并发请求无法满足。&lt;/p&gt;
&lt;p&gt;解决办法：集群 分布式&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>集合底层原理--HashTable</title>
    <link href="http://yoursite.com/2019/11/08/%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-HashTable/"/>
    <id>http://yoursite.com/2019/11/08/集合底层原理-HashTable/</id>
    <published>2019-11-08T01:37:25.000Z</published>
    <updated>2019-11-11T05:29:44.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>底层数组+链表实现key和value不能为Null</p><a id="more"></a><h3 id="Curr"><a href="#Curr" class="headerlink" title="Curr"></a>Curr</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h3&gt;&lt;h3 id=&quot;HashTable&quot;&gt;&lt;a href=&quot;#HashTable&quot; class=&quot;headerlink&quot; title=&quot;HashTable&quot;&gt;&lt;/a&gt;HashTable&lt;/h3&gt;&lt;p&gt;底层数组+链表实现key和value不能为Null&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
